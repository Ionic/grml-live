#!/bin/bash
# Filename:      grml-live
# Purpose:       build process script for generating a (grml based) Linux Live-ISO
# Authors:       grml-team (grml.org),
#                (c) Michael Prokop <mika@grml.org>,
#                (c) Thorsten Glaser <tg@mirbsd.org>
# Bug-Reports:   see http://grml.org/bugs/
# License:       This file is licensed under the GPL v2 or any later version.
################################################################################

# read configuration files, set some misc variables {{{

export LANG=C
export LC_ALL=C

# define function getfilesize before "set -e"
if stat --help >/dev/null 2>&1; then
	getfilesize='stat -c %s'	# GNU stat
else
	getfilesize='stat -f %z'	# BSD stat
fi

# exit on any error:
set -e

GRML_LIVE_VERSION='0.9.20'
PN="$(basename $0)"
CMDLINE="$0 $@"
ISO_DATE="$(date +%Y-%m-%d)"
SOURCES_LIST_FILE='/etc/grml/fai/apt/sources.list'

# usage information {{{
usage()
{
  echo "
$PN - build process script for generating a (grml based) Linux Live-ISO

Usage: $PN [options, see as follows]

   -a <architecture>       architecture; available values: i386 and amd64
   -b                      build the ISO without updating the chroot via FAI
   -B                      build the ISO without touching the chroot (skips cleanup)
   -c <classe[s]>          classes to be used for building the ISO via FAI
   -C <configfile>         configuration file for grml-live
   -F                      force execution without prompting
   -g <grml_name>]         set the grml flavour name
   -h                      display short usage information and exit
   -i <iso_name>           name of ISO
   -o <output_directory>   main output directory of the build process
   -q                      skip mksquashfs
   -r <release_name<       release name
   -s <suite>              Debian suite; values: etch, lenny, squeeze, sid
   -t <template_directory> place of the templates
   -u                      update existing chroot instead of rebuilding it from scratch
   -v <version_number>     specify version number of the release
   -V                      increase verbosity in the build process
   -z                      use ZLIB instead of LZMA compression (depends on
                           squashfs-tools version)

Usage examples:

    $PN
    $PN -c GRMLBASE,GRML_MEDIUM,I386 -o /dev/shm/grml
    $PN -c GRMLBASE,GRML_SMALL,REMOVE_DOCS,I386 -g grml-small -v 1.0
    $PN -c GRMLBASE,GRML_FULL,I386 -i grml_0.0-1.iso -v 0.0-1
    $PN -c GRMLBASE,GRML_FULL,I386 -s sid -V -r 'grml-live rocks'

More details: man grml-live + /usr/share/doc/grml-live/grml-live.html
              http://grml.org/grml-live/

Please send your bug reports and feedback to the grml-team: http://grml.org/bugs/
"
}

# make sure it's possible to get usage information without being
# root or actually executing the script
if [ "$1" = '-h' -o "$1" = '--help' ] ; then
   usage
   [ "$(id -u 2>/dev/null)" != 0 ] && echo "Please notice that this script requires root permissions."
   exit 0
fi
# }}}

# we need root permissions for the build-process:
if [ "$(id -u 2>/dev/null)" != 0 ] ; then
   echo "Error: please run this script with uid 0 (root)." >&2
   exit 1
fi

if [ -r /var/run/fai/FAI_INSTALLATION_IN_PROGRESS ] ; then
   echo "/usr/sbin/fai already running or was aborted before.">&2
   echo "You may remove /var/run/fai/FAI_INSTALLATION_IN_PROGRESS and try again.">&2
   exit 1
fi

# see #449236
if [ -r /var/run/fai/fai_softupdate_is_running ] ; then
   echo "/usr/sbin/fai softupdate already running or was aborted before.">&2
   echo "You may remove /var/run/fai/fai_softupdate_is_running and try again.">&2
   exit 1
fi

# make sure they are not set by default
VERBOSE=''
FORCE=''
UPDATE=''
BUILD_ONLY=''
BUILD_DIRTY=''
HOSTNAME=''

if [ -r /etc/grml/lsb-functions ] ; then
   . /etc/grml/lsb-functions
else
   einfo()  { echo "  [*] $*" ;}
   eerror() { echo "  [!] $*">&2 ;}
   ewarn()  { echo "  [x] $*" ;}
   eend()   { return 0 ;}
fi

# source main configuration file:
LIVE_CONF=/etc/grml/grml-live.conf
. $LIVE_CONF

# }}}

# clean exit {{{
bailout() {
  rm -f /var/run/fai/fai_softupdate_is_running \
        /var/run/fai/FAI_INSTALLATION_IN_PROGRESS
  [ -n "$MIRROR_DIRECTORY" ] && umount "${CHROOT_OUTPUT}/${MIRROR_DIRECTORY}"
  [ -n "$1" ] && EXIT="$1" || EXIT="1"
  [ -n "$2" ] && eerror "$2">&2
  log "------------------------------------------------------------------------------"
  exit "$EXIT"
}
trap bailout 1 2 3 3 6 9 14 15
# }}}

# check for important variables {{{
[ -n "$GRML_FAI_CONFIG" ] || GRML_FAI_CONFIG=/etc/grml/fai
[ -n "$HOSTNAME" ] || HOSTNAME=grml
[ -n "$USERNAME" ] || USERNAME=grml
[ -n "$CLASSES" ]  || CLASSES="GRML,I386"
[ -n "$BOOT_METHOD" ] || BOOT_METHOD='isolinux'
[ -n "$OUTPUT" ] || bailout 1 "${PN}: \$OUTPUT not specified. Please adjust $LIVE_CONF. Exiting."

[ -n "$VERSION" ]  || VERSION="0.0.1"
[ -n "$RELEASENAME" ] || RELEASENAME="grml-live rocks"
[ -n "$GRML_NAME" ] || GRML_NAME='grml'

# logfile:
if [ -z "$LOGFILE" ] ; then
   LOGFILE=/var/log/grml-live.log
fi
touch $LOGFILE
chown root:adm $LOGFILE
chmod 664 $LOGFILE

NFSROOT_CONF=/etc/grml/fai/make-fai-nfsroot.conf

# }}}

# some important functions {{{

# log output:
# usage: log "string to log"
log() { echo "$*" >> $LOGFILE ; }

# cut string at character number int = $1
# usage: cut_string 5 "1234567890" will output "12345"
cut_string() {
  [ -n "$2" ] || return 1
  echo "$2" | head -c "$1"; echo -ne "\n"
}

# prepend int = $1 spaces before string = $2
# usage: extend_string_begin 5 "123" will output "  123"
extend_string_begin() {
  [ -n "$2" ] || return 1
  local COUNT="$(echo $2 | wc -c)"
  local FILL="$(expr $COUNT - $1)"
  while [ "$FILL" -gt 1 ] ; do
    echo -n " "
    local FILL=$(expr $FILL - 1)
  done
  while [ "$FILL" -lt 1 ] ; do
    echo -n " "
    local FILL=$(expr $FILL + 1)
  done
  echo "$2" | head -c "$1"; echo -ne "\n"
}

# append int = $1 spaces to string = $2
# usage: extend_string_begin 5 "123" will output "123  "
extend_string_end() {
  [ -n "$2" ] || return 1
  echo -n "$2" | head -c "$1"
  local COUNT="$(echo $2 | wc -c)"
  local FILL="$(expr $COUNT - $1)"
  while [ "$FILL" -gt 1 ] ; do
    echo -n " "
    local FILL=$(expr $FILL - 1)
  done
  while [ "$FILL" -lt 1 ] ; do
    echo -n " "
    local FILL=$(expr $FILL + 1)
  done
  echo -ne "\n"
}
# }}}

# read local (non-packaged) configuration {{{
LOCAL_CONFIG=/etc/grml/grml-live.local
if [ -r "$LOCAL_CONFIG" ] ; then
   log "Sourcing $LOCAL_CONFIG"
   . $LOCAL_CONFIG
else
   log "No $LOCAL_CONFIG found, not sourcing it"
   LOCAL_CONFIG=''
fi
# }}}

# command line parsing {{{
while getopts "a:C:c:g:i:o:r:s:t:v:bBFuqVz" opt; do
  case "$opt" in
    a) ARCH="$OPTARG" ;;
    b) BUILD_ONLY=1 ;;
    B) BUILD_DIRTY=1 ;;
    c) CLASSES="$OPTARG" ;;
    C) CONFIG="$OPTARG" ;;
    g) GRML_NAME="$OPTARG" ;;
    i) ISO_NAME="$OPTARG" ;;
    o) OUTPUT="$OPTARG"
       CHROOT_OUTPUT="$OUTPUT/grml_chroot"
       BUILD_OUTPUT="$OUTPUT/grml_cd"
       ISO_OUTPUT="$OUTPUT/grml_isos"
       ;;
    q) SKIP_MKSQUASHFS=1 ;;
    r) RELEASENAME="$OPTARG" ;;
    s) SUITE="$OPTARG" ;;
    t) TEMPLATE_DIRECTORY="$OPTARG";;
    v) VERSION="$OPTARG" ;;
    F) FORCE=1 ;;
    u) UPDATE=1 ;;
    V) VERBOSE="-v" ;;
    z) SQUASHFS_ZLIB="-nolzma" ;;
    ?) echo "invalid option -$OPTARG" >&2; bailout 1 ;;
  esac
done
shift $(($OPTIND - 1))  # set ARGV to the first not parsed commandline parameter
# }}}

# some misc checks before executing FAI {{{
[ -n "$CLASSES" ] || bailout 1 "Error: \$CLASSES unset, please set it in $LIVE_CONF or
specify it on the command line using the -c option."
[ -n "$OUTPUT" ] || bailout 1 "Error: \$OUTPUT unset, please set it in $LIVE_CONF or
specify it on the command line using the -o option."

# trim characters that are known to cause problems inside $GRML_NAME;
# for example isolinux does not like '-' inside the directory name
[ -n "$GRML_NAME" ] && export SHORT_GRML_NAME="$(echo $GRML_NAME | tr -d ',./;\- ')"

# export variables to have them available in fai scripts:
[ -n "$GRML_NAME" ]   && export GRML_NAME="$GRML_NAME"
[ -n "$RELEASENAME" ] && export RELEASENAME="$RELEASENAME"
# }}}

# clean/zero grml-live logfile {{{
if [ -n "$ZERO_LOGFILE" ] ; then
   echo -n > $LOGFILE
fi
# }}}

# clean/zero/remove old FAI directory {{{
if [ -n "$ZERO_FAI_LOGFILE" ] ; then
   if [ -d /var/log/fai/"$HOSTNAME" ] ; then
      rm -rf /var/log/fai/"$HOSTNAME"/"$(readlink /var/log/fai/"$HOSTNAME"/last)"
      rm -rf /var/log/fai/"$HOSTNAME"/"$(readlink /var/log/fai/"$HOSTNAME"/last-dirinstall)"
      rm -rf /var/log/fai/"$HOSTNAME"/"$(readlink /var/log/fai/"$HOSTNAME"/last-softupdate)"
      rm -f /var/log/fai/"$HOSTNAME"/last \
            /var/log/fai/"$HOSTNAME"/last-dirinstall \
            /var/log/fai/"$HOSTNAME"/last-softupdate
   fi
fi
# }}}

# ask user whether the setup is ok {{{
if [ -z "$FORCE" ] ; then
   echo
   echo "${PN} [${GRML_LIVE_VERSION}]: check your configuration (or use -F to force execution):"
   echo
   echo "  FAI classes:       $CLASSES"
   [ -r "$LOCAL_CONFIG" ]       && echo "  local config:      /etc/grml/grml-live.local"
   [ -n "$CONFIG" ]             && echo "  configuration:     $CONFIG"
   echo "  main directory:    $OUTPUT"
   [ -n "$CHROOT_OUTPUT" ]      && echo "  chroot target:     $CHROOT_OUTPUT"
   [ -n "$BUILD_OUTPUT" ]       && echo "  build target:      $BUILD_OUTPUT"
   [ -n "$ISO_OUTPUT" ]         && echo "  ISO target:        $ISO_OUTPUT"
   [ -n "$GRML_NAME" ]          && echo "  grml name:         $GRML_NAME"
   [ -n "$RELEASENAME" ]        && echo "  release name:      $RELEASENAME"
   [ -n "$VERSION" ]            && echo "  grml version:      $VERSION"
   [ -n "$SUITE" ]              && echo "  Debian suite:      $SUITE"
   [ -n "$ARCH" ]               && echo "  Architecture:      $ARCH"
   [ -n "$BOOT_METHOD" ]        && echo "  Boot method:       $BOOT_METHOD"
   [ -n "$TEMPLATE_DIRECTORY" ] && echo "  Template files:    $TEMPLATE_DIRECTORY"
   [ -n "$FAI_ARGS" ]           && echo "  additional arguments for FAI: $FAI_ARGS"
   [ -n "$LOGFILE" ]            && echo "  Logging to file:   $LOGFILE"
   [ -n "$SQUASHFS_ZLIB" ]      && echo "  Using ZLIB (instead of LZMA) compression."
   [ -n "$SQUASHFS_OPTIONS" ]   && echo "  Using SQUASHFS_OPTIONS ${SQUASHFS_OPTIONS}"
   [ -n "$VERBOSE" ]            && echo "  Using VERBOSE mode."
   [ -n "$UPDATE" ]             && echo "  Executing UPDATE instead of fresh installation."
   [ -n "$SKIP_MKSQUASHFS" ]    && echo "  Skipping creation of SQUASHFS file."
   [ -n "$BUILD_ONLY" ]         && echo "  Executing BUILD_ONLY instead of fresh installation or UPDATE."
   [ -n "$BUILD_DIRTY" ]        && echo "  Executing BUILD_DIRTY to leave chroot untouched."
   echo
   echo -n "Is this ok for you? [y/N] "
   read a
   if ! [ "$a" = 'y' -o "$a" = 'Y' ] ; then
      bailout 1 "Exiting as requested."
   fi
   echo
fi

if [ -n "$CONFIG" ] ; then
   if ! [ -f "$CONFIG" ] ; then
      log "Sorry, $CONFIG could not be read. Exiting. [$(date)]"
      eerror "Sorry, $CONFIG could not be read. Exiting."
      bailout 1
   else
      log "Sourcing $CONFIG"
      . $CONFIG
   fi
fi

start_seconds=$(cut -d . -f 1 /proc/uptime)
log "------------------------------------------------------------------------------"
log "Starting grml-live [${GRML_LIVE_VERSION}] run on $(date)"
log "Executed grml-live command line:"
log "$CMDLINE"

einfo "Logging actions to logfile $LOGFILE"
# }}}

# on-the-fly configuration {{{
if [ -n "$MIRROR_DIRECTORY" ] ; then
   if ! [ -d "$MIRROR_DIRECTORY/debian" ] ; then
      log "Sorry, $MIRROR_DIRECTORY/debian does not seem to exist. Exiting. [$(date)]"
      eerror "Sorry, $MIRROR_DIRECTORY/debian does not seem to exist. Exiting."
      bailout 1
   fi
   cat > "$SOURCES_LIST_FILE" << EOF
# NOTE: This file is *NOT* meant for manual customisation! This file is
# modified by grml-live and any changes might be overriden.
# You might consider using GRML_LIVE_SOURCES in /etc/grml/grml-live.conf*
# and using /etc/grml/fai/files/etc/apt instead!'
EOF
   echo "$MIRROR_SOURCES" >> "$SOURCES_LIST_FILE"
   if [ -n "$GRML_LIVE_SOURCES" ] ; then
      echo "$GRML_LIVE_SOURCES" >> "$SOURCES_LIST_FILE"
   fi
elif [ -n "$GRML_LIVE_SOURCES" ] ; then
   cat > "$SOURCES_LIST_FILE" << EOF
# NOTE: This file is *NOT* meant for manual customisation! This file is
# modified by grml-live and any changes might be overriden.
# You might consider using GRML_LIVE_SOURCES in /etc/grml/grml-live.conf*
# and using /etc/grml/fai/files/etc/apt instead!'
EOF
   echo "$GRML_LIVE_SOURCES" >> "$SOURCES_LIST_FILE"
fi

if [ -n "$FAI_DEBOOTSTRAP" ] ; then
   sed "s#^FAI_DEBOOTSTRAP=.*#FAI_DEBOOTSTRAP=\"$FAI_DEBOOTSTRAP\"#" "$NFSROOT_CONF" | sponge "$NFSROOT_CONF"
fi

# does this suck? YES!
if [ -n "$SUITE" ] ; then

   # /usr/share/debootstrap/scripts/unstable does not exist, instead use 'sid':
   case $SUITE in
      unstable) SUITE='sid' ;;
   esac

   DIST=" etch\| stable\| lenny\| squeeze\| testing\| sid\| unstable"
   sed "s/\(^deb .\+\)\([ \t]*\)\($DIST\)\([ \t]*\)\(main \)/\1 \2$SUITE\4\5/" "$SOURCES_LIST_FILE" | sponge "$SOURCES_LIST_FILE"
   for file in "$LIVE_CONF" "$CONFIG" "$LOCAL_CONFIG" ; do
       if [ -n "$file" ] ; then
          sed "s/^SUITE=.*/SUITE=\"$SUITE\"/" $file | sponge $file
          sed "s/\(^deb .\+\)\([ \t]*\)\($DIST\)\([ \t]*\)\(main \)/\1 \2$SUITE\4\5/" "$file" | sponge "$file"
       fi
   done

   # notice: activate grml-live pool only if we are building against unstable:
   if grep -qe unstable -qe sid "$SOURCES_LIST_FILE" ; then
      grep -q 'grml-live.*main' "$SOURCES_LIST_FILE" || \
      grep grml-stable "$SOURCES_LIST_FILE" | \
           sed 's/grml-stable/grml-live/' >> "$SOURCES_LIST_FILE"
   else
      grep -q 'grml-live.*main' "$SOURCES_LIST_FILE" && \
      sed 's/.*grml-live.*/# removed grml-live repository/' "$SOURCES_LIST_FILE" | sponge "$SOURCES_LIST_FILE"
   fi

   for file in "$LIVE_CONF" "$CONFIG" "$LOCAL_CONFIG" "$NFSROOT_CONF" ; do
       if [ -n "$file" ] ; then
          sed "s|^FAI_DEBOOTSTRAP=\"[a-z]* |FAI_DEBOOTSTRAP=\"$SUITE |" "$file" | sponge "$file"
       fi
   done
fi

# set $ARCH
[ -n "$ARCH" ] || ARCH="$(dpkg --print-architecture)"
if grep -q -- 'FAI_DEBOOTSTRAP_OPTS.*--arch' "$NFSROOT_CONF" ; then
   sed "s/--arch [a-z0-9]* /--arch $ARCH /" "$NFSROOT_CONF" | sponge "$NFSROOT_CONF"
else
   sed "s|^FAI_DEBOOTSTRAP_OPTS=\"\(.*\)|FAI_DEBOOTSTRAP_OPTS=\"--arch $ARCH \1|" "$NFSROOT_CONF" | sponge "$NFSROOT_CONF"
fi
# }}}

# CHROOT_OUTPUT - execute FAI {{{
if [ -n "$BUILD_DIRTY" ]; then
  einfo "Skipping FAI" ; eend 0
else
   [ -n "$CHROOT_OUTPUT" ] || CHROOT_OUTPUT="$OUTPUT/grml_chroot"

   if [ -n "$UPDATE" -o -n "$BUILD_ONLY" ] ; then
      FAI_ACTION=softupdate
   else
      FAI_ACTION=dirinstall
   fi

   if [ -n "$UPDATE" -o -n "$BUILD_ONLY" ] ; then
      if ! [ -r "$CHROOT_OUTPUT/etc/grml_version" ] ; then
         log "Error: does not look like you have a working chroot. Updating/building not possible."
         eerror "Error: does not look like you have a working chroot. Updating/building not possible. (Drop -u/-b option?)"
         eend 1
         bailout 20
      fi
   fi

   if [ -d "$CHROOT_OUTPUT/bin" -a -z "$UPDATE" -a -z "$BUILD_ONLY" ] ; then
      log "$CHROOT_OUTPUT exists already, skipping stage 'fai dirinstall'"
      ewarn "$CHROOT_OUTPUT exists already, skipping stage 'fai dirinstall'" ; eend 0
   else
      mkdir -p "$CHROOT_OUTPUT" || bailout 5 "Problem with creating $CHROOT_OUTPUT for FAI"

      if [ -n "${MIRROR_DIRECTORY}" ] ; then
         mkdir -p "${CHROOT_OUTPUT}/${MIRROR_DIRECTORY}"
         mount --bind "${MIRROR_DIRECTORY}" "${CHROOT_OUTPUT}/${MIRROR_DIRECTORY}"
      fi

      log "Executed FAI command line:"
      log "BUILD_ONLY=$BUILD_ONLY fai $VERBOSE -C $GRML_FAI_CONFIG -c$CLASSES -u $HOSTNAME $FAI_ACTION $CHROOT_OUTPUT $FAI_ARGS"
      BUILD_ONLY="$BUILD_ONLY" fai $VERBOSE -C "$GRML_FAI_CONFIG" -c"$CLASSES" -u \
      "$HOSTNAME" $FAI_ACTION "$CHROOT_OUTPUT" $FAI_ARGS | tee -a $LOGFILE
      RC="$PIPESTATUS" # notice: bash-only

      if [ "$RC" != 0 ] ; then
         log "Error while executing fai [exit code ${RC}]. Exiting."
         eerror "Error while executing fai [exit code ${RC}]. Exiting." ; eend 1
         bailout 1
      else
         log "Setting /etc/grml_version to $GRML_NAME $VERSION Release Codename $RELEASENAME [$ISO_DATE]"
         echo "$GRML_NAME $VERSION Release Codename $RELEASENAME [$ISO_DATE]" > $CHROOT_OUTPUT/etc/grml_version
         chmod 644 $CHROOT_OUTPUT/etc/grml_version
         einfo "Rebuilding initramfs"
         # make sure new /etc/grml_version reaches the initramfs:
         chroot $CHROOT_OUTPUT update-initramfs -u -t
         eend $?
      fi

      # Remove all FAI logs from chroot if class RELEASE is used:
      if [ -f "$CHROOT_OUTPUT"/etc/grml_fai_release ] ; then
         rm -rf "$CHROOT_OUTPUT"/var/log/fai/*
      fi

      # make sure we don't leave any mounts - FAI doesn't remove them always
      umount $CHROOT_OUTPUT/proc 2>/dev/null || /bin/true
      umount $CHROOT_OUTPUT/sys  2>/dev/null || /bin/true
      umount $CHROOT_OUTPUT/dev/pts 2>/dev/null || /bin/true
      umount $CHROOT_OUTPUT/dev 2>/dev/null || /bin/true

      [ -n "$MIRROR_DIRECTORY" ] && umount "${CHROOT_OUTPUT}/${MIRROR_DIRECTORY}"

      # notice: 'fai dirinstall' does not seem to exit appropriate, so:
      ERROR=''
      CHECKLOG=/var/log/fai/$HOSTNAME/last
      if [ -r "$CHECKLOG/software.log" ] ; then
         # 1 errors during executing of commands
         grep 'dpkg: error processing' $CHECKLOG/software.log >> $LOGFILE && ERROR=1
         grep 'E: Method http has died unexpectedly!' $CHECKLOG/software.log >> $LOGFILE && ERROR=2
         grep 'ERROR: chroot' $CHECKLOG/software.log >> $LOGFILE && ERROR=3
         grep 'E: Failed to fetch' $CHECKLOG/software.log >> $LOGFILE && ERROR=4
         grep 'Unable to write mmap - msync (28 No space left on device)' $CHECKLOG/software.log >> $LOGFILE && ERROR=5
      fi

      if [ -r "$CHECKLOG/shell.log" ] ; then
         grep 'FAILED with exit code' $CHECKLOG/shell.log >> $LOGFILE && ERROR=2
      fi

      if [ -n "$ERROR" ] ; then
         log "There was an error [${ERROR}] during execution of stage 'fai dirinstall' [$(date)]"
         eerror "There was an error during execution of stage 'fai dirinstall'"
         echo "   Check out ${CHECKLOG}/ for details. [exit ${ERROR}]"
         eend 1
         bailout 1
      else
         log "Finished execution of stage 'fai dirinstall' [$(date)]"
         einfo "Finished execution of stage 'fai dirinstall'"
      fi

   fi
fi # BUILD_DIRTY?
# }}}

# BUILD_OUTPUT - execute arch specific stuff and squashfs {{{
[ -n "$BUILD_OUTPUT" ] || BUILD_OUTPUT="$OUTPUT/grml_cd"
mkdir -p "$BUILD_OUTPUT" || bailout 6 "Problem with creating $BUILD_OUTPUT for stage ARCH"

# i386:
if [ "$ARCH" = i386 ] || [ "$ARCH" = amd64 ] ; then
   if [ -d "$BUILD_OUTPUT"/boot -a -z "$UPDATE" -a -z "$BUILD_ONLY" ] ; then
      log "$BUILD_OUTPUT/boot exists already, skipping stage 'boot'"
      ewarn "$BUILD_OUTPUT/boot exists already, skipping stage 'boot'" ; eend 0
   else
      # booting stuff:
      [ -d "$BUILD_OUTPUT"/boot/isolinux ] || mkdir -p "$BUILD_OUTPUT"/boot/isolinux
      [ -d "$BUILD_OUTPUT"/boot/"${SHORT_GRML_NAME}" ] || mkdir -p "$BUILD_OUTPUT"/boot/"${SHORT_GRML_NAME}"

      if [ -z "$NO_ADDONS" ] ; then
         [ -d "$BUILD_OUTPUT"/boot/addons   ] || mkdir -p "$BUILD_OUTPUT"/boot/addons
         cp /boot/memtest86+.bin "$BUILD_OUTPUT"/boot/addons/memtest
      fi

      # if we don't have an initrd we a) can't boot and b) there was an error
      # during build, so check for the file:
      INITRD="$(ls $CHROOT_OUTPUT/boot/initrd* 2>/dev/null| grep -v '.bak$' | sort -r | head -1)"
      if [ -n "$INITRD" ] ; then
         cp $INITRD "$BUILD_OUTPUT"/boot/"${SHORT_GRML_NAME}"/initrd.gz
         find $CHROOT_OUTPUT/boot/ -name initrd\*.bak -exec rm {} \;
      else
         log "No initrd found inside $CHROOT_OUTPUT/boot/ - Exiting"
         eerror "No initrd found inside $CHROOT_OUTPUT/boot/ - Exiting" ; eend 1
         bailout 10
      fi

      KERNEL_IMAGE="$(ls $CHROOT_OUTPUT/boot/vmlinuz* 2>/dev/null | sort -r | head -1)"
      if [ -n "$KERNEL_IMAGE" ] ; then
         cp "$KERNEL_IMAGE" "$BUILD_OUTPUT"/boot/"${SHORT_GRML_NAME}"/linux26
      else
         log "No kernel found inside $CHROOT_OUTPUT/boot/ - Exiting"
         eerror "No kernel found inside $CHROOT_OUTPUT/boot/ - Exiting" ; eend 1
         bailout 11
      fi

      [ -n "$TEMPLATE_DIRECTORY" ] || TEMPLATE_DIRECTORY='/usr/share/grml-live/templates'
      if ! [ -d "${TEMPLATE_DIRECTORY}"/boot ] ; then
         log "${TEMPLATE_DIRECTORY}/boot does not exist. Exiting."
         eerror "${TEMPLATE_DIRECTORY}/boot does not exist. Exiting." ; eend 1
         bailout 8
      fi

      cp ${TEMPLATE_DIRECTORY}/boot/isolinux/*  "$BUILD_OUTPUT"/boot/isolinux/

      if [ -z "$NO_ADDONS" ] ; then
         if ! [ -d /usr/share/grml-live/templates/boot/addons/bsd4grml ] ; then
           ewarn "Boot addons not found, skipping therefore. (Consider installing package grml-live-addons)" ; eend 0
         else
           # copy only files so we can handle bsd4grml on its own
           for file in ${TEMPLATE_DIRECTORY}/boot/addons/* ; do
               test -f $file && cp $file "$BUILD_OUTPUT"/boot/addons/
           done

           if [ -z "$NO_ADDONS_BSD4GRML" ] ; then
              cp -a ${TEMPLATE_DIRECTORY}/boot/addons/bsd4grml "$BUILD_OUTPUT"/boot/addons/
           fi
         fi
      fi

      if ! [ -d "${BUILD_OUTPUT}/boot/grub" ] ; then
         cp -a ${TEMPLATE_DIRECTORY}/boot/grub  "$BUILD_OUTPUT"/boot/
      fi
      # make sure we have recent template files available, otherwise updating
      # the strings like $GRML_NAME and $VERSION might be out of date
      cp ${TEMPLATE_DIRECTORY}/boot/grub/* "$BUILD_OUTPUT"/boot/grub/

      if ! [ -d "${TEMPLATE_DIRECTORY}"/GRML ] ; then
         log "${TEMPLATE_DIRECTORY}/GRML does not exist. Exiting."
         eerror "${TEMPLATE_DIRECTORY}/GRML does not exist. Exiting." ; eend 1
         bailout 9
      fi

      [ -d "$BUILD_OUTPUT"/GRML ] || mkdir "$BUILD_OUTPUT"/GRML
      cp -a ${TEMPLATE_DIRECTORY}/GRML/* "$BUILD_OUTPUT"/GRML/

      # adjust boot splash information:
      RELEASE_INFO="$GRML_NAME $VERSION - Release Codename $RELEASENAME"
      RELEASE_INFO="$(cut_string 68 "$RELEASE_INFO")"
      RELEASE_INFO="$(extend_string_end 68 "$RELEASE_INFO")"

      sed -i "s/%RELEASE_INFO%/$GRML_NAME $VERSION - $RELEASENAME/" "$BUILD_OUTPUT"/GRML/grml-version
      sed -i "s/%DATE%/$ISO_DATE/"             "$BUILD_OUTPUT"/GRML/grml-version

      sed -i "s/%RELEASE_INFO%/$RELEASE_INFO/" "$BUILD_OUTPUT"/boot/isolinux/boot.msg
      sed -i "s/%DATE%/$ISO_DATE/"             "$BUILD_OUTPUT"/boot/isolinux/boot.msg

      sed -i "s/%GRML_NAME%/$SHORT_GRML_NAME/" "$BUILD_OUTPUT"/boot/isolinux/isolinux.cfg
      sed -i "s/%GRML_NAME%/$SHORT_GRML_NAME/" "$BUILD_OUTPUT"/boot/isolinux/syslinux.cfg

      sed -i "s/%RELEASE_INFO%/$RELEASE_INFO/" "$BUILD_OUTPUT"/boot/isolinux/boot-beep.msg
      sed -i "s/%DATE%/$ISO_DATE/"             "$BUILD_OUTPUT"/boot/isolinux/boot-beep.msg

      sed -i "s/%VERSION%/$VERSION/"           "$BUILD_OUTPUT"/boot/grub/menu.lst
      sed -i "s/%GRML_NAME%/$SHORT_GRML_NAME/" "$BUILD_OUTPUT"/boot/grub/menu.lst

      sed -i "s/%VERSION%/$VERSION/"           "$BUILD_OUTPUT"/boot/grub/grub.cfg
      sed -i "s/%GRML_NAME%/$SHORT_GRML_NAME/" "$BUILD_OUTPUT"/boot/grub/grub.cfg

      # make sure the squashfs filename is set accordingly:
      GRML_NAME_SQUASHFS="$GRML_NAME.squashfs"
      sed -i "s/%GRML_NAME_SQUASHFS%/$GRML_NAME_SQUASHFS/" "$BUILD_OUTPUT"/boot/isolinux/isolinux.cfg
      sed -i "s/%GRML_NAME_SQUASHFS%/$GRML_NAME_SQUASHFS/" "$BUILD_OUTPUT"/boot/isolinux/syslinux.cfg
      sed -i "s/%GRML_NAME_SQUASHFS%/$GRML_NAME_SQUASHFS/" "$BUILD_OUTPUT"/boot/grub/menu.lst

      GRML_NAME_SQUASHFS="$(cut_string 20 "$GRML_NAME_SQUASHFS")"
      GRML_NAME_SQUASHFS="$(extend_string_end 20 "$GRML_NAME_SQUASHFS")"
      sed -i "s/%GRML_NAME_SQUASHFS%/$GRML_NAME_SQUASHFS/" "$BUILD_OUTPUT"/boot/isolinux/f4
      sed -i "s/%GRML_NAME_SQUASHFS%/$GRML_NAME_SQUASHFS/" "$BUILD_OUTPUT"/boot/isolinux/f5

      # jump back to grub from bsd4grml:
      if [ -e "$BUILD_OUTPUT"/boot/addons/bsd4grml/boot.6 ]; then
         if [ -e "$BUILD_OUTPUT"/boot/grub/core.img ]; then
            GRUB_VERSION=2
         else
            GRUB_VERSION=1
         fi
         if [ -e "$BUILD_OUTPUT"/boot/grub/stage2 ]; then
            GRUB_LEGACY=stage2
         else
            GRUB_LEGACY=stage2_eltorito
         fi

         # why not ed(1)?
         for file in "$BUILD_OUTPUT"/boot/addons/bsd4grml/boot.6 \
                     "$BUILD_OUTPUT"/boot/addons/bsd4grml/boot.cfg; do
             sed -i -e "s!%GRUB_VERSION%!$GRUB_VERSION!g" \
                    -e "s!%GRUB_LEGACY%!$GRUB_LEGACY!g" "$file"
         done
      fi

      # autostart for Windows:
      if [ -d "${TEMPLATE_DIRECTORY}/windows/autostart/" ] ; then
         cp ${TEMPLATE_DIRECTORY}/windows/autostart/* "$BUILD_OUTPUT"/
      fi

      # windows-binaries:
      if [ -n "$WINDOWS_BINARIES" ] ; then
         if [ -f "$BUILD_OUTPUT"/windows/putty.exe ] ; then
            log "$BUILD_OUTPUT/windows exists already, skipping stage 'WINDOWS_BINARIES'"
            ewarn "$BUILD_OUTPUT/windows exists already, skipping stage 'WINDOWS_BINARIES'" ; eend 0
         else
            if ! [ -d "$BUILD_OUTPUT"/windows ] ; then
               mkdir "$BUILD_OUTPUT"/windows
               ( cd "$BUILD_OUTPUT"/windows
                 for file in pageant plink pscp psftp putty puttygen ; do
                    wget -O ${file}.exe ${WINDOWS_BINARIES}/${file}.exe
                    md5sum ${file}.exe > ${file}.exe.md5
                 done )
            fi
         fi
      log "Finished execution of stage 'WINDOWS_BINARIES' [$(date)]"
      einfo "Finished execution of stage 'WINDOWS_BINARIES'" ; eend 0
      fi
   einfo "Finished execution of stage 'boot'" ; eend 0
   fi
# ppc:
elif [ "$ARCH" = powerpc ] ; then
    ewarn 'Warning: formorer, it is your turn. :)'>&2
# unsuported:
else
   eerror 'Error: Unsupported ARCH, sorry. Want to support it? Contribute!' ; eend 1
fi

if [ -f "$BUILD_OUTPUT"/live/${GRML_NAME}.squashfs -a -z "$UPDATE" -a -z "$BUILD_ONLY" -a -z "$BUILD_DIRTY" ] ; then
   log "$BUILD_OUTPUT/live exists already, skipping stage 'squashfs'"
   ewarn "$BUILD_OUTPUT/live exists already, skipping stage 'squashfs'" ; eend 0
elif [ -n "$SKIP_MKSQUASHFS" ] ; then
   log "Skipping stage 'squashfs' as requested via option -q"
   ewarn "Skipping stage 'squashfs' as requested via option -q" ; eend 0
else
   [ -d "$BUILD_OUTPUT"/live ] || mkdir "$BUILD_OUTPUT"/live
   # make sure we don't leave (even an empty) base.tgz:
   [ -f "$CHROOT_OUTPUT/base.tgz" ] && rm -f "$CHROOT_OUTPUT/base.tgz"

   # make sure mksquashfs can handle the according option:
   if [ -n "$SQUASHFS_ZLIB" ] ; then
      mksquashfs --help 2>&1 | grep -q -- "$SQUASHFS_ZLIB" || SQUASHFS_ZLIB=''
   fi

   if echo "$SQUASHFS_OPTIONS" | grep -q -- "-nolzma" ; then
      if ! mksquashfs --help 2>&1 | grep -q -- '-nolzma' ; then
         ewarn "mksquashfs does NOT support the nolzma option, just using default zlib mode."
         SQUASHFS_OPTIONS="$(echo $SQUASHFS_OPTIONS | sed 's/-nolzma//g')"
         eend 0
      fi
   fi

   if echo "$SQUASHFS_OPTIONS" | grep -q -- "-lzma" ; then
      if ! mksquashfs --help 2>&1 | grep -q -- '-lzma' ; then
         ewarn "mksquashfs does NOT support the lzma option, falling back to zlib mode."
         SQUASHFS_OPTIONS="$(echo $SQUASHFS_OPTIONS | sed 's/-lzma//g')"
         eend 0
      fi
   fi

   # support exclusion of files via exclude-file:
   if [ -n "$SQUASHFS_EXCLUDES_FILE" -a "$SQUASHFS_EXCLUDES_FILE" ] ; then
      SQUASHFS_OPTIONS="$SQUASHFS_OPTIONS -ef $SQUASHFS_EXCLUDES_FILE"
   fi

   # get rid of unnecessary files when building grml-small for final release:
   if echo "$CLASSES" | grep -q GRML_SMALL ; then
      SQUASHFS_OPTIONS="$SQUASHFS_OUTPUT -e initrd.img* vmlinuz*"
   fi

   SQUASHFS_OUTPUT="$(mktemp -t grml-live.XXXXXX)"
   log "mksquashfs $CHROOT_OUTPUT/* $BUILD_OUTPUT/live/${GRML_NAME}.squashfs -noappend $SQUASHFS_OPTIONS $SQUASHFS_ZLIB"
   if mksquashfs $CHROOT_OUTPUT/* $BUILD_OUTPUT/live/"${GRML_NAME}".squashfs \
      -noappend $SQUASHFS_OPTIONS $SQUASHFS_ZLIB 2>"${SQUASHFS_OUTPUT}" ; then
      echo "${GRML_NAME}.squashfs" > $BUILD_OUTPUT/live/filesystem.module
      log "Finished execution of stage 'squashfs' [$(date)]"
      einfo "Finished execution of stage 'squashfs'" ; eend 0
      rm -f "${SQUASHFS_OUTPUT}"
   else
      log "There was an error executing stage 'squashfs' [$(date)]:"
      log "$(cat $SQUASHFS_OUTPUT)"
      eerror "There was an error executing stage 'squashfs':" ; eend 1
      cat "${SQUASHFS_OUTPUT}"
      rm -f "${SQUASHFS_OUTPUT}"
      bailout
   fi
fi

# create md5sum file:
( cd $BUILD_OUTPUT/GRML &&
find .. -type f -not -name md5sums -not -name isolinux.bin -exec md5sum {} \; > md5sums )
# }}}

# ISO_OUTPUT - mkisofs {{{
[ -n "$ISO_OUTPUT" ] || ISO_OUTPUT="$OUTPUT/grml_isos"
[ -n "$ISO_NAME" ] || ISO_NAME="${GRML_NAME}_${VERSION}.iso"

if [ "$BOOT_METHOD" = "isolinux" ] ; then
   BOOT_FILE="boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat"
elif [ "$BOOT_METHOD" = "grub" ] ; then
   BOOT_FILE="boot/grub/stage2_eltorito"
fi

if [ -f "${ISO_OUTPUT}/${ISO_NAME}" -a -z "$UPDATE" -a -z "$BUILD_ONLY" -a -z "$BUILD_DIRTY" ] ; then
   log "$ISO_OUTPUT exists already, skipping stage 'iso build'"
   ewarn "$ISO_OUTPUT exists already, skipping stage 'iso build'" ; eend 0
else
   mkdir -p "$ISO_OUTPUT" || bailout 6 "Problem with creating $ISO_OUTPUT for stage 'iso build'"

   CURRENT_DIR=$(pwd)
   if cd "$BUILD_OUTPUT" ; then
      log "mkisofs -V '${GRML_NAME} ${VERSION}' -publisher 'grml-live | grml.org' -l -r -J -no-emul-boot -boot-load-size 4 -boot-info-table -b $BOOT_FILE -o ${ISO_OUTPUT}/${ISO_NAME} ."
      mkisofs -V "${GRML_NAME} ${VERSION}" -publisher 'grml-live | grml.org' \
              -l -r -J -no-emul-boot -boot-load-size 4 -boot-info-table    \
              -b $BOOT_FILE -no-pad \
              -o "${ISO_OUTPUT}/${ISO_NAME}" . ; RC=$?

      # pad the output ISO to multiples of 256 KiB for partition table support
      siz=$($getfilesize "${ISO_OUTPUT}/${ISO_NAME}")
      cyls=$((siz / 512 / 32 / 16 + 1))		# C=$cyls H=16 S=32
      siz=$((cyls * 16 * 32 * 512))		# size after padding
      dd if=/dev/zero bs=1 count=1 seek=$((siz - 1)) \
         of="${ISO_OUTPUT}/${ISO_NAME}" 2>/dev/null

      # support disabling hybrid ISO image
      if [ "$HYBRID_METHOD" = "disable" ] ; then\
         log "Skipping creation of hybrid ISO file as requested via HYBRID_METHOD=disable"
         einfo "Skipping creation of hybrid ISO file as requested via HYBRID_METHOD=disable"
         eend 0
      # use isohybrid only on request
      elif [ "$HYBRID_METHOD" = "isohybrid" ] ; then
         if ! which isohybrid >/dev/null 2>&1 ; then
           bailout 12 "isohybrid binary not found - please install syslinux/syslinux-common"
         else
           log "Creating hybrid ISO file with isohybrid method"
           einfo "Creating hybrid ISO file with isohybrid method"
           isohybrid "${ISO_OUTPUT}/${ISO_NAME}"
           eend $?
         fi
      # by default use our manifold boot method:
      else
         if ! [ -r boot/grub/core.img ] ; then
           ewarn "boot/grub/core.img not found, not creating manifold boot ISO file"
         else
           log "Creating hybrid ISO file with manifold method"
           einfo "Creating hybrid ISO file with manifold method"
           echo 1 63 | \
               mksh /usr/share/grml-live/scripts/bootgrub.mksh -A -M 1 -p 0x83 -g $cyls:16:32 | \
               cat - boot/grub/core.img | \
               dd conv=notrunc of="${ISO_OUTPUT}/${ISO_NAME}" conv=notrunc 2>/dev/null
           eend $?
         fi
      fi

      # generate md5sum and sha1sum of ISO if we are using class 'RELEASE':
      case $CLASSES in *RELEASE*)
         [ "$RC" = 0 ] && \
         (
           if cd $ISO_OUTPUT ; then
             md5sum ${ISO_NAME} > ${ISO_NAME}.md5 && \
             touch -r ${ISO_NAME} ${ISO_NAME}.md5
             sha1sum ${ISO_NAME} > ${ISO_NAME}.sha1 && \
             touch -r ${ISO_NAME} ${ISO_NAME}.sha1
           fi
         )
         ;;
      esac

      cd $CURRENT_DIR
   fi

   if [ "$RC" = 0 ] ; then
      log "Finished execution of stage 'iso build' [$(date)]"
      einfo "Finished execution of stage 'iso build'" ; eend 0
   else
      log "There was an error ($RC) executing stage 'iso build' [$(date)]"
      eerror "There was an error executing stage 'iso build'" ; eend 1
      bailout $RC
   fi
fi
# }}}

# finalize {{{
[ -n "$start_seconds" ] && SECONDS="$[$(cut -d . -f 1 /proc/uptime)-$start_seconds]" || SECONDS="unknown"
einfo "Sucessfully finished execution of $PN [running ${SECONDS} seconds]" ; eend 0
log "Sucessfully finished execution of $PN [running ${SECONDS} seconds]"
bailout 0
# }}}

## END OF FILE #################################################################
# vim:foldmethod=marker ts=2 ft=sh ai expandtab tw=80 sw=3
