#!/bin/bash
# Filename:      grml-live
# Purpose:       build process script for generating a (grml based) Linux Live-ISO
# Authors:       grml-team (grml.org),
#                (c) Michael Prokop <mika@grml.org>,
#                (c) Thorsten Glaser <tg@mirbsd.org>
# Bug-Reports:   see http://grml.org/bugs/
# License:       This file is licensed under the GPL v2 or any later version.
################################################################################

# some misc and global stuff {{{
export LANG=C
export LC_ALL=C

# define function getfilesize before "set -e"
if stat --help >/dev/null 2>&1; then
  getfilesize='stat -c %s'  # GNU stat
else
  getfilesize='stat -f %z'  # BSD stat
fi

# exit on any error:
# disable for now since it seems to cause some problems
# set -e

# global variables
GRML_LIVE_VERSION='0.17.0'
PN="$(basename $0)"
CMDLINE="$0 $@"
ADDONS_LIST_FILE='/boot/isolinux/addons_list.cfg'
# }}}

# usage information {{{
usage()
{
  echo "
$PN - build process script for generating a (grml based) Linux Live-ISO

Usage: $PN [options, see as follows]

   -a <architecture>       architecture; available values: i386 and amd64
   -A                      ensure clean build and pack artifacts
   -b                      build the ISO without updating the chroot via FAI
   -B                      build the ISO without touching the chroot (skips cleanup)
   -c <classe[s]>          classes to be used for building the ISO via FAI
   -C <configfile>         configuration file for grml-live
   -d <date>               use specified date instead of build time as date of release
   -D <configdir>          use specified configuration directory instead of /etc/grml/fai
   -F                      force execution without prompting
   -g <grml_name>          set the grml flavour name
   -h                      display short usage information and exit
   -i <iso_name>           name of ISO
   -I <src_directory>      directory which provides files that should become
                           part of the chroot/ISO
   -n                      skip generation of ISO
   -N                      bootstrap (build chroot) only, do not create files for ISO
   -o <output_directory>   main output directory of the build process
   -q                      skip mksquashfs
   -Q                      skip netboot package build
   -r <release_name>       release name
   -s <suite>              Debian suite; values: etch, lenny, squeeze, sid
   -t <template_directory> place of the templates
   -T <tar_name>           unpack chroot tar archive before starting
   -u                      update existing chroot instead of rebuilding it from scratch
   -U <username>           arrange output to be owned by specified username
   -v <version_number>     specify version number of the release
   -V                      increase verbosity in the build process
   -z                      use ZLIB instead of LZMA/XZ compression

Usage examples:

    $PN
    $PN -c GRMLBASE,GRML_FULL,AMD64 -o /dev/shm/grml
    $PN -c GRMLBASE,GRML_FULL,AMD64 -i grml_0.0-1.iso -v 0.0-1
    $PN -c GRMLBASE,GRML_FULL,AMD64 -s sid -V -r 'grml-live rocks'

More details: man grml-live + /usr/share/doc/grml-live/grml-live.html
              http://grml.org/grml-live/

Please send your bug reports and feedback to the grml-team: http://grml.org/bugs/
"
}

# make sure it's possible to get usage information without being
# root or actually executing the script
if [ "$1" = '-h' -o "$1" = '--help' ] ; then
   usage
   [ "$(id -u 2>/dev/null)" != 0 ] && echo "Please notice that this script requires root permissions."
   exit 0
fi
# }}}

# some runtime checks {{{
# we need root permissions for the build-process:
if [ "$(id -u 2>/dev/null)" != 0 ] ; then
   echo "Error: please run this script with uid 0 (root)." >&2
   exit 1
fi

if [ -r /var/run/fai/FAI_INSTALLATION_IN_PROGRESS ] ; then
   echo "/usr/sbin/fai already running or was aborted before.">&2
   echo "You may remove /var/run/fai/FAI_INSTALLATION_IN_PROGRESS and try again.">&2
   exit 1
fi

# see #449236
if [ -r /var/run/fai/fai_softupdate_is_running ] ; then
   echo "/usr/sbin/fai softupdate already running or was aborted before.">&2
   echo "You may remove /var/run/fai/fai_softupdate_is_running and try again.">&2
   exit 1
fi
# }}}

# lsb-functions and configuration stuff {{{
# make sure they are not set by default
VERBOSE=''
FORCE=''
UPDATE=''
BUILD_ONLY=''
BUILD_DIRTY=''
BOOTSTRAP_ONLY=''
HOSTNAME=''
USERNAME=''
CONFIGDUMP=''

# don't use colors/escape sequences
if [ -r /lib/lsb/init-functions ] ; then
  . /lib/lsb/init-functions
  ! log_use_fancy_output && NOCOLORS=true
fi

if [ -r /etc/grml/lsb-functions ] ; then
   . /etc/grml/lsb-functions
else
   einfo()  { echo "  [*] $*" ;}
   eerror() { echo "  [!] $*">&2 ;}
   ewarn()  { echo "  [x] $*" ;}
   eend()   { return 0 ;}
   eindent()  { return 0 ;}
   eoutdent() { return 0 ;}
fi

# source main configuration file:
LIVE_CONF=/etc/grml/grml-live.conf
. $LIVE_CONF
# }}}

# umount all directories {{{
umount_all() {
   # make sure we don't leave any mounts - FAI doesn't remove them always
   umount $CHROOT_OUTPUT/proc 2>/dev/null || /bin/true
   umount $CHROOT_OUTPUT/sys  2>/dev/null || /bin/true
   umount $CHROOT_OUTPUT/dev/pts 2>/dev/null || /bin/true
   umount $CHROOT_OUTPUT/dev 2>/dev/null || /bin/true

   # certain FAI versions sadly leave a ramdisk behind, so better safe than sorry
   if [ -x /usr/lib/fai/mkramdisk ] ; then
     /usr/lib/fai/mkramdisk -u "$(readlink -f ${CHROOT_OUTPUT}/var/lib/dpkg)" >/dev/null 2>&1 || /bin/true
   fi

   umount "${CHROOT_OUTPUT}/grml-live/sources/" 2>/dev/null || /bin/true
   [ -n "$MIRROR_DIRECTORY" ] && umount "${CHROOT_OUTPUT}/${MIRROR_DIRECTORY}"
}
# }}}

# clean exit {{{
bailout() {
  rm -f /var/run/fai/fai_softupdate_is_running \
        /var/run/fai/FAI_INSTALLATION_IN_PROGRESS
  [ -n "$CONFIGDUMP"      ]  && rm -f  "$CONFIGDUMP"
  [ -n "$SQUASHFS_STDERR" ]  && rm -rf "$SQUASHFS_STDERR"
  umount_all
  [ -n "$1" ] && EXIT="$1" || EXIT="1"
  [ -n "$2" ] && eerror "$2">&2
  if [ -n "$PACK_ARTIFACTS" ]; then
    log "Cleaning up"
    einfo "Cleaning up"
    [ -n "${BUILD_OUTPUT}"  -a -d "${BUILD_OUTPUT}"  ] && rm -r "${BUILD_OUTPUT}"
    [ -n "${CHROOT_OUTPUT}" -a -d "${CHROOT_OUTPUT}" ] && rm -r "${CHROOT_OUTPUT}"
    eend 0
  fi
  if [ -n "$CHOWN_USER" ]; then
    log "Setting ownership"
    einfo "Setting ownership"
    [ -n "${OUTPUT}"         -a -d "${OUTPUT}"         ] && chown -R "${CHOWN_USER}:" "${OUTPUT}"
    [ -n "${BUILD_OUTPUT}"   -a -d "${BUILD_OUTPUT}"   ] && chown -R "${CHOWN_USER}:" "${BUILD_OUTPUT}"
    [ -n "${CHROOT_OUTPUT}"  -a -d "${CHROOT_OUTPUT}"  ] && chown -R "${CHOWN_USER}:" "${CHROOT_OUTPUT}"
    [ -n "${ISO_OUTPUT}"     -a -d "${ISO_OUTPUT}"     ] && chown -R "${CHOWN_USER}:" "${ISO_OUTPUT}"
    [ -n "${LOG_OUTPUT}"     -a -d "${LOG_OUTPUT}"     ] && chown -R "${CHOWN_USER}:" "${LOG_OUTPUT}"
    [ -n "${NETBOOT}"        -a -d "${NETBOOT}"        ] && chown -R "${CHOWN_USER}:" "${NETBOOT}"
    [ -n "${CHROOT_ARCHIVE}" -a -f "${CHROOT_ARCHIVE}" ] && chown -R "${CHOWN_USER}:" "${CHROOT_ARCHIVE}"
    eend 0
  fi
  log "------------------------------------------------------------------------------"
  exit "$EXIT"
}
trap bailout 1 2 3 3 6 9 14 15
trap umount_all EXIT
# }}}

# some important functions {{{

# log output:
# usage: log "string to log"
log() { [ -n "$LOGFILE" ] && echo "$*" >> $LOGFILE ; }

# cut string at character number int = $1
# usage: cut_string 5 "1234567890" will output "12345"
cut_string() {
  [ -n "$2" ] || return 1
  echo "$2" | head -c "$1"; echo -ne "\n"
}

# prepend int = $1 spaces before string = $2
# usage: extend_string_begin 5 "123" will output "  123"
extend_string_begin() {
  [ -n "$2" ] || return 1
  local COUNT="$(echo $2 | wc -c)"
  local FILL="$(expr $COUNT - $1)"
  while [ "$FILL" -gt 1 ] ; do
    echo -n " "
    local FILL=$(expr $FILL - 1)
  done
  while [ "$FILL" -lt 1 ] ; do
    echo -n " "
    local FILL=$(expr $FILL + 1)
  done
  echo "$2" | head -c "$1"; echo -ne "\n"
}

# append int = $1 spaces to string = $2
# usage: extend_string_begin 5 "123" will output "123  "
extend_string_end() {
  [ -n "$2" ] || return 1
  echo -n "$2" | head -c "$1"
  local COUNT="$(echo $2 | wc -c)"
  local FILL="$(expr $COUNT - $1)"
  while [ "$FILL" -gt 1 ] ; do
    echo -n " "
    local FILL=$(expr $FILL - 1)
  done
  while [ "$FILL" -lt 1 ] ; do
    echo -n " "
    local FILL=$(expr $FILL + 1)
  done
  echo -ne "\n"
}

# Copy addonfile $1 from either
#   * the chroot (via $2, the system path),
#   * or from TEMPLATE_DIRECTORY/compat (if exists),
#   * or from the host system (again, using $2),
# or warn about the missing file.
#
# This is because:
#   * We assume that the chroot always has a "good" version of
#     the file. Also it makes sources handling easier.
#   * On unstable, we Recommend the Debian packages containing
#     these files. The user can override them by putting his
#     "better" version into the chroot.
#   * On stable, the Debian packages are probably not available,
#     or outdated, so we look in TEMPLATE_DIRECTORY/compat first, where
#     our grml-live-compat package installs current file versions.
copy_addon_file() {
  DEST="${BUILD_OUTPUT}/boot/$3"
  if [ ! -d "${DEST}/" ]; then
    mkdir -p "${DEST}"
  fi
  if [ -e "$CHROOT_OUTPUT/$2/$1" ]; then
    log   "Copying $1 from chroot"
    cp "$CHROOT_OUTPUT/$2/$1" "${DEST}/"
    return $?
  fi
  if [ -e "${TEMPLATE_DIRECTORY}/compat/$3/$1" ]; then
    log   "Copying $1 from grml-live-compat"
    cp "${TEMPLATE_DIRECTORY}/compat/$3/$1" "${DEST}/"
    return $?
  fi
  if [ -e "$2/$1" ]; then
    log   "Copying $1 from system"
    cp "$2/$1" "${DEST}/"
    return $?
  fi

  msg="Missing addon file: \"$1\""
  ewarn "$msg" ; eend 1
  log "copy_addon_file: $msg"
}
# }}}

# command line parsing {{{
while getopts "a:C:c:d:D:g:i:I:o:r:s:t:T:U:v:AbBFnNqQuVz" opt; do
  case "$opt" in
    a) ARCH="$OPTARG" ;;
    A) PACK_ARTIFACTS=1 ;;
    b) BUILD_ONLY=1 ;;
    B) BUILD_DIRTY=1 ;;
    c) CLASSES="$OPTARG" ;;
    C) LOCAL_CONFIG="$(readlink -f $OPTARG)" ;;
    d) DATE="$OPTARG" ;;
    D) GRML_FAI_CONFIG="$(readlink -f $OPTARG)" ;;
    g) GRML_NAME="$OPTARG" ;;
    i) ISO_NAME="$OPTARG" ;;
    I) CHROOT_INSTALL="$OPTARG" ;;
    n) SKIP_MKISOFS=1 ;;
    N) BOOTSTRAP_ONLY=1; SKIP_MKISOFS=1; SKIP_MKSQUASHFS=1 ;;
    o) OUTPUT="$(readlink -f $OPTARG)" ;;
    q) SKIP_MKSQUASHFS=1 ;;
    Q) SKIP_NETBOOT=1 ;;
    r) RELEASENAME="$OPTARG" ;;
    s) SUITE="$OPTARG" ;;
    t) TEMPLATE_DIRECTORY="$OPTARG";;
    T) UNPACK_CHROOT="$(readlink -f $OPTARG)" ;;
    v) VERSION="$OPTARG" ;;
    F) FORCE=1 ;;
    u) UPDATE=1 ;;
    U) CHOWN_USER="$OPTARG" ;;
    V) VERBOSE="-v" ;;
    z) SQUASHFS_ZLIB=1 ;;
    ?) echo "invalid option -$OPTARG" >&2; bailout 1 ;;
  esac
done
shift $(($OPTIND - 1))  # set ARGV to the first not parsed commandline parameter
# }}}

# read local (non-packaged) configuration {{{
if [ -z "$LOCAL_CONFIG" ]; then
  if [ -r "/etc/grml/grml-live.local" ]; then
    LOCAL_CONFIG="/etc/grml/grml-live.local"
  fi
fi
if [ -n "$LOCAL_CONFIG" ]; then
  if [ -r "$LOCAL_CONFIG" ]; then
    . $LOCAL_CONFIG
  else
    eerror "Could not read specified local configuration file \"$LOCAL_CONFIG\"."
    bailout 1
  fi
  LOCAL_CONFIG=$(readlink -f "$LOCAL_CONFIG")
else
  LOCAL_CONFIG=''
fi

if [ -n "${GRML_LIVE_SOURCES:-}" ] ; then
  eerror "Config variable \$GRML_LIVE_SOURCES is set. This variable has been deprecated."
  ewarn  "Please set up \${GRML_FAI_CONFIG}/config/files/etc/apt/sources.list.d/* instead."
  bailout 1
fi
# }}}

# assume sane defaults (if not set already) {{{
[ -n "$ARCH" ]                    || ARCH="$(dpkg --print-architecture)"
[ -n "$BOOT_METHOD" ]             || BOOT_METHOD='isolinux'
[ -n "$CLASSES" ]                 || CLASSES="GRMLBASE,GRML_FULL,$(echo ${ARCH} | tr 'a-z' 'A-Z')"
[ -n "$DATE" ]                    || DATE="$(date +%Y-%m-%d)"
[ -n "$DISTRI_INFO" ]             || DISTRI_INFO='Grml - Live Linux for system administrators   '
[ -n "$DISTRI_NAME" ]             || DISTRI_NAME="grml"
[ -n "$DISTRI_SPLASH" ]           || DISTRI_SPLASH='grml.png'
[ -n "$FORCE_ISO_REBUILD" ]       || FORCE_ISO_REBUILD="false"
[ -n "$GRML_FAI_CONFIG" ]         || GRML_FAI_CONFIG='/etc/grml/fai'
[ -n "$GRML_NAME" ]               || GRML_NAME='grml'
[ -n "$HOSTNAME" ]                || HOSTNAME='grml'
[ -n "$HYBRID_METHOD" ]           || HYBRID_METHOD='manifold'
[ -n "$NFSROOT_CONF" ]            || NFSROOT_CONF="${GRML_FAI_CONFIG}/make-fai-nfsroot.conf"
[ -n "$RELEASENAME" ]             || RELEASENAME='grml-live rocks'
[ -n "$SQUASHFS_EXCLUDES_FILE" ]  || SQUASHFS_EXCLUDES_FILE="${GRML_FAI_CONFIG}/config/grml/squashfs-excludes"
[ -n "$SUITE" ]                   || SUITE='squeeze'
[ -n "$TEMPLATE_DIRECTORY" ]      || TEMPLATE_DIRECTORY='/usr/share/grml-live/templates'
[ -n "$USERNAME" ]                || USERNAME='grml'
[ -n "$VERSION" ]                 || VERSION='0.0.1'

# output specific stuff, depends on $OUTPUT (iff not set):
[ -n "$OUTPUT" ]           || OUTPUT='/grml/grml-live'
[ -n "$BUILD_OUTPUT" ]     || BUILD_OUTPUT="$OUTPUT/grml_cd"
[ -n "$CHROOT_OUTPUT" ]    || CHROOT_OUTPUT="$OUTPUT/grml_chroot"
[ -n "$CHROOT_ARCHIVE" ]   || CHROOT_ARCHIVE="$OUTPUT/$(basename $CHROOT_OUTPUT).tgz"
[ -n "$ISO_OUTPUT" ]       || ISO_OUTPUT="$OUTPUT/grml_isos"
[ -n "$LOG_OUTPUT" ]       || LOG_OUTPUT="$OUTPUT/grml_logs"
[ -n "$REPORTS" ]          || REPORTS="${LOG_OUTPUT}/reports/"
[ -n "$NETBOOT" ]          || NETBOOT="${OUTPUT}/netboot/"
# }}}

# some misc checks before executing FAI {{{
[ -n "$CLASSES" ] || bailout 1 "Error: \$CLASSES unset, please set it in $LIVE_CONF or
specify it on the command line using the -c option."
[ -n "$OUTPUT" ] || bailout 1 "Error: \$OUTPUT unset, please set it in $LIVE_CONF or
specify it on the command line using the -o option."

# trim characters that are known to cause problems inside $GRML_NAME;
# for example isolinux does not like '-' inside the directory name
[ -n "$GRML_NAME" ] && export SHORT_NAME="$(echo $GRML_NAME | tr -d ',./;\- ')"

# export variables to have them available in fai scripts:
[ -n "$GRML_NAME" ]   && export GRML_NAME="$GRML_NAME"
[ -n "$RELEASENAME" ] && export RELEASENAME="$RELEASENAME"
# }}}

# ZERO_LOGFILE - check for backwards compatibility reasons {{{
# this was default behaviour until grml-live 0.9.34:
if [ -n "$ZERO_LOGFILE" ] ; then
   PRESERVE_LOGFILE='' # make sure it's cleaned then
   ewarn "Please consider disabling the \$ZERO_LOGFILE option as grml-live clears..."
   ewarn "... the logfile $LOGFILE by default (unless \$PRESERVE_LOGFILE is set) nowadays."
   eend 0
fi
# }}}

# ask user whether the setup is ok {{{
if [ -z "$FORCE" ] ; then
   echo
   echo "${PN} [${GRML_LIVE_VERSION}]: check your configuration (or use -F to force execution):"
   echo
   echo "  FAI classes:       $CLASSES"
   [ -n "$LOCAL_CONFIG" ]        && echo "  Configuration:     $LOCAL_CONFIG"
   [ -n "$GRML_FAI_CONFIG" ]     && echo "  Config directory:  $GRML_FAI_CONFIG"
   echo "  main directory:    $OUTPUT"
   [ -n "$UNPACK_CHROOT" ]       && echo "  Chroot from:       $UNPACK_CHROOT"
   [ -n "$CHROOT_OUTPUT" ]       && echo "  Chroot target:     $CHROOT_OUTPUT"
   [ -n "$BUILD_OUTPUT" ]        && echo "  Build target:      $BUILD_OUTPUT"
   [ -n "$ISO_OUTPUT" ]          && echo "  ISO target:        $ISO_OUTPUT"
   [ -n "$GRML_NAME" ]           && echo "  Grml name:         $GRML_NAME"
   [ -n "$RELEASENAME" ]         && echo "  Release name:      $RELEASENAME"
   [ -n "$DATE" ]                && echo "  Build date:        $DATE"
   [ -n "$VERSION" ]             && echo "  Grml version:      $VERSION"
   [ -n "$SUITE" ]               && echo "  Debian suite:      $SUITE"
   [ -n "$ARCH" ]                && echo "  Architecture:      $ARCH"
   [ -n "$BOOT_METHOD" ]         && echo "  Boot method:       $BOOT_METHOD"
   [ -n "$HYBRID_METHOD" ]       && echo "  Hybrid method:     $HYBRID_METHOD"
   [ -n "$TEMPLATE_DIRECTORY" ]  && echo "  Template files:    $TEMPLATE_DIRECTORY"
   [ -n "$CHROOT_INSTALL" ]      && echo "  Install files from directory to chroot:  $CHROOT_INSTALL"
   [ -n "$BOOTID" ]              && echo "  Boot identifier:   $BOOTID"
   [ -n "$NO_BOOTID" ]           && echo "  Skipping bootid feature."
   [ -n "$CHOWN_USER" ]          && echo "  Output owner:      $CHOWN_USER"
   [ -n "$DEFAULT_BOOTOPTIONS" ] && echo "  Adding default bootoptions: \"$DEFAULT_BOOTOPTIONS\""
   [ -n "$FAI_ARGS" ]            && echo "  Additional arguments for FAI: $FAI_ARGS"
   [ -n "$LOGFILE" ]             && echo "  Logging to file:   $LOGFILE"
   [ -n "$SQUASHFS_ZLIB" ]       && echo "  Using ZLIB (instead of LZMA/XZ) compression."
   [ -n "$SQUASHFS_OPTIONS" ]    && echo "  Using SQUASHFS_OPTIONS ${SQUASHFS_OPTIONS}"
   [ -n "$VERBOSE" ]             && echo "  Using VERBOSE mode."
   [ -n "$PACK_ARTIFACTS" ]      && echo "  Will prepare packed artifacts and ensure clean build."
   [ -n "$UPDATE" ]              && echo "  Executing UPDATE instead of fresh installation."
   if [ -n "$BOOTSTRAP_ONLY" ] ; then
     echo "  Bootstrapping only and not building (files for) ISO."
   else
     [ -n "$SKIP_MKSQUASHFS" ]     && echo "  Skipping creation of SQUASHFS file."
     [ -n "$SKIP_NETBOOT" ]        && echo "  Skipping creation of NETBOOT package."
     [ -n "$SKIP_MKISOFS" ]        && echo "  Skipping creation of ISO file."
     [ -n "$BUILD_ONLY" ]          && echo "  Executing BUILD_ONLY instead of fresh installation or UPDATE."
     [ -n "$BUILD_DIRTY" ]         && echo "  Executing BUILD_DIRTY to leave chroot untouched."
   fi
   echo
   echo -n "Is this ok for you? [y/N] "
   read a
   if ! [ "$a" = 'y' -o "$a" = 'Y' ] ; then
      bailout 1 "Exiting as requested."
   fi
   echo
fi
# }}}

# clean up before start {{{
if [ -n "${PACK_ARTIFACTS}" ]; then
  echo "Wiping old artifacts"
  [ -n "${CHROOT_OUTPUT}"  -a -d "${CHROOT_OUTPUT}"  ] && rm -r "${CHROOT_OUTPUT}"
  [ -n "${BUILD_OUTPUT}"   -a -d "${BUILD_OUTPUT}"   ] && rm -r "${BUILD_OUTPUT}"
  [ -n "${ISO_OUTPUT}"     -a -d "${ISO_OUTPUT}"     ] && rm -r "${ISO_OUTPUT}"
  [ -n "${LOG_OUTPUT}"     -a -d "${LOG_OUTPUT}"     ] && rm -r "${LOG_OUTPUT}"
  [ -n "${NETBOOT}"        -a -d "${NETBOOT}"        ] && rm -r "${NETBOOT}"
fi
# }}}

# create log file {{{
[ -n "$LOGFILE" ] || LOGFILE=${LOG_OUTPUT}/grml-live.log
mkdir -p $(dirname "${LOGFILE}")
touch $LOGFILE
chown root:adm $LOGFILE
chmod 664 $LOGFILE
# }}}

# clean/zero/remove logfiles {{{

if [ -n "$PRESERVE_LOGFILE" ] ; then
   echo "Preserving logfile $LOGFILE as requested via \$PRESERVE_LOGFILE"
else
   # make sure it is empty (as it is e.g. appended to grml-live-db)
   echo -n > $LOGFILE
fi

if [ -n "$ZERO_FAI_LOGFILE" ] ; then
   if [ -d /var/log/fai/"$HOSTNAME" ] ; then
      rm -rf /var/log/fai/"$HOSTNAME"/"$(readlink /var/log/fai/"$HOSTNAME"/last)"
      rm -rf /var/log/fai/"$HOSTNAME"/"$(readlink /var/log/fai/"$HOSTNAME"/last-dirinstall)"
      rm -rf /var/log/fai/"$HOSTNAME"/"$(readlink /var/log/fai/"$HOSTNAME"/last-softupdate)"
      rm -f /var/log/fai/"$HOSTNAME"/last \
            /var/log/fai/"$HOSTNAME"/last-dirinstall \
            /var/log/fai/"$HOSTNAME"/last-softupdate
   fi
fi
# }}}

# source config and startup {{{
if [ -n "$CONFIG" ] ; then
   if ! [ -f "$CONFIG" ] ; then
      log    "Error: $CONFIG could not be read. Exiting. [$(date)]"
      eerror "Error: $CONFIG could not be read. Exiting." ; eend 1
      bailout 1
   else
      log "Sourcing $CONFIG"
      . $CONFIG
   fi
fi

start_seconds=$(cut -d . -f 1 /proc/uptime)
log "------------------------------------------------------------------------------"
log "Starting grml-live [${GRML_LIVE_VERSION}] run on $(date)"
log "Using local config file: $LOCAL_CONFIG"
log "Executed grml-live command line:"
log "$CMDLINE"

einfo "Logging actions to logfile $LOGFILE"
# }}}

# dump config variables into file, for script access {{{
CONFIGDUMP=$(mktemp)
set | egrep \
  '^(GRML_NAME|RELEASENAME|DATE|VERSION|SUITE|ARCH|DISTRI_NAME|USERNAME|HOSTNAME|APT_PROXY)=' \
  > ${CONFIGDUMP}
# }}}

# unpack chroot {{{
if [ -n "${UNPACK_CHROOT}" ]; then
  log "Unpacking chroot from ${UNPACK_CHROOT}"
  einfo "Unpacking chroot from ${UNPACK_CHROOT}"
  [ -d "$CHROOT_OUTPUT" ] || mkdir -p "${CHROOT_OUTPUT}"
  tar -xf "${UNPACK_CHROOT}" -C "${CHROOT_OUTPUT}/" --strip-components 1 ; RC=$?
  if [ "$RC" != 0 ] ; then
    eend 1
    bailout 1
  fi
  eend 0
fi
# }}}

# cleanup CHROOT_ARCHIVE now {{{
if [ -n "${PACK_ARTIFACTS}" ]; then
  # can't do this earlier, as UNPACK_CHROOT might point to CHROOT_ARCHIVE
  [ -n "${CHROOT_ARCHIVE}" -a -f "${CHROOT_ARCHIVE}" ] && rm "${CHROOT_ARCHIVE}"
fi
# }}}

# on-the-fly configuration {{{
if [ -n "$FAI_DEBOOTSTRAP" ] ; then
  sed "s#^FAI_DEBOOTSTRAP=.*#FAI_DEBOOTSTRAP=\"$FAI_DEBOOTSTRAP\"#" "$NFSROOT_CONF" | sponge "$NFSROOT_CONF"
fi

# does this suck? YES!
# /usr/share/debootstrap/scripts/unstable does not exist, instead use 'sid':
case $SUITE in
   unstable) SUITE='sid' ; CLASSES="DEBIAN_UNSTABLE,$CLASSES" ;;
   *) CLASSES="DEBIAN_$(echo $SUITE | tr 'a-z' 'A-Z'),$CLASSES";;
esac
export SUITE # make sure it's available in FAI scripts

for file in "$LIVE_CONF" "$LOCAL_CONFIG" "$NFSROOT_CONF" ; do
    if [ -n "$file" ] ; then
       sed "s|^FAI_DEBOOTSTRAP=\"[a-z]* |FAI_DEBOOTSTRAP=\"$SUITE |" "$file" | sponge "$file"
    fi
done

# validate whether the specified architecture class matches the
# architecture (option), otherwise installation of kernel will fail
if echo $CLASSES | grep -qi i386 ; then
   if ! [[ "$ARCH" == "i386" ]] ; then
      log    "Error: You specified the I386 class but are trying to build something else (AMD64?)."
      eerror "Error: You specified the I386 class but are trying to build something else (AMD64?)."
      eerror "Tip:   Either invoke grml-live with '-a i386' or adjust the architecture class. Exiting."
      eend 1
      bailout
   fi
elif echo $CLASSES | grep -qi amd64 ; then
   if ! [[ "$ARCH" == "amd64" ]] ; then
      log    "Error: You specified the AMD64 class but are trying to build something else (I386?)."
      eerror "Error: You specified the AMD64 class but are trying to build something else (I386?)."
      eerror "Tip:   Either invoke grml-live with '-a amd64' or adjust the architecture class. Exiting."
      eend 1
      bailout
   fi
fi

if grep -q -- 'FAI_DEBOOTSTRAP_OPTS.*--arch' "$NFSROOT_CONF" ; then
   sed "s/--arch [a-z0-9]* /--arch $ARCH /" "$NFSROOT_CONF" | sponge "$NFSROOT_CONF"
else
   sed "s|^FAI_DEBOOTSTRAP_OPTS=\"\(.*\)|FAI_DEBOOTSTRAP_OPTS=\"--arch $ARCH \1|" "$NFSROOT_CONF" | sponge "$NFSROOT_CONF"
fi
# }}}

# CHROOT_OUTPUT - execute FAI {{{
if [ -n "$BUILD_DIRTY" ]; then
   log   "Skipping stage 'fai' as requested via option -B"
   ewarn "Skipping stage 'fai' as requested via option -B" ; eend 0
else
   [ -n "$CHROOT_OUTPUT" ] || CHROOT_OUTPUT="$OUTPUT/grml_chroot"

   # provide inform fai about the ISO we build
   [ -d "$CHROOT_OUTPUT/etc/" ] || mkdir -p "$CHROOT_OUTPUT/etc/"
   echo '# This file has been generated by grml-live.' > "$CHROOT_OUTPUT/etc/grml_live_version"
   [ -n "$GRML_LIVE_VERSION" ] && echo "GRML_LIVE_VERSION=$GRML_LIVE_VERSION" >> "$CHROOT_OUTPUT/etc/grml_live_version"
   [ -n "$SUITE" ] && echo "SUITE=$SUITE" >> "$CHROOT_OUTPUT/etc/grml_live_version"

   if [ -n "$UPDATE" -o -n "$BUILD_ONLY" ] ; then
      FAI_ACTION=softupdate
   else
      FAI_ACTION=dirinstall
   fi

   if [ -n "$UPDATE" -o -n "$BUILD_ONLY" ] ; then
      if ! [ -r "$CHROOT_OUTPUT/etc/debian_version" ] ; then
         log    "Error: does not look like you have a working chroot. Updating/building not possible."
         eerror "Error: does not look like you have a working chroot. Updating/building not possible. (Drop -u/-b option?)"
         eend 1
         bailout 20
      fi
   fi

   if [ -d "$CHROOT_OUTPUT/bin" -a -z "$UPDATE" -a -z "$BUILD_ONLY" ] ; then
      log   "Skipping stage 'fai dirinstall' as $CHROOT_OUTPUT exists already."
      ewarn "Skipping stage 'fai dirinstall' as $CHROOT_OUTPUT exists already." ; eend 0
   else
      mkdir -p "$CHROOT_OUTPUT" || bailout 5 "Problem with creating $CHROOT_OUTPUT for FAI"

      if [ -n "${MIRROR_DIRECTORY}" ] ; then
         mkdir -p "${CHROOT_OUTPUT}/${MIRROR_DIRECTORY}"
         mount --bind "${MIRROR_DIRECTORY}" "${CHROOT_OUTPUT}/${MIRROR_DIRECTORY}"
      fi

      mkdir -p "${OUTPUT}/grml_sources/" "${CHROOT_OUTPUT}/grml-live/sources/"
      mount --bind "${OUTPUT}/grml_sources/" "${CHROOT_OUTPUT}/grml-live/sources/"

      # tell dpkg to use "unsafe io" during the build
      [ -d "$CHROOT_OUTPUT/etc/dpkg/dpkg.cfg.d" ] || mkdir -p "$CHROOT_OUTPUT/etc/dpkg/dpkg.cfg.d"
      echo force-unsafe-io > "$CHROOT_OUTPUT/etc/dpkg/dpkg.cfg.d/unsafe-io"

      log "Executed FAI command line:"
      log "BUILD_ONLY=$BUILD_ONLY BOOTSTRAP_ONLY=$BOOTSTRAP_ONLY GRML_LIVE_CONFIG=$CONFIGDUMP fai $VERBOSE -C $GRML_FAI_CONFIG -s file:///$GRML_FAI_CONFIG/config -c$CLASSES -u $HOSTNAME $FAI_ACTION $CHROOT_OUTPUT $FAI_ARGS"
      BUILD_ONLY="$BUILD_ONLY" BOOTSTRAP_ONLY="$BOOTSTRAP_ONLY" GRML_LIVE_CONFIG="$CONFIGDUMP" fai $VERBOSE \
                  -C "$GRML_FAI_CONFIG" -s "file:///$GRML_FAI_CONFIG/config" -c"$CLASSES" \
                  -u "$HOSTNAME" "$FAI_ACTION" "$CHROOT_OUTPUT" $FAI_ARGS | tee -a $LOGFILE
      RC="$PIPESTATUS" # notice: bash-only

      rm -f "$CHROOT_OUTPUT/etc/dpkg/dpkg.cfg.d/unsafe-io"

      FORCE_ISO_REBUILD=true

      if [ "$RC" != 0 ] ; then
         log    "Error: critical error while executing fai [exit code ${RC}]. Exiting."
         eerror "Error: critical error while executing fai [exit code ${RC}]. Exiting." ; eend 1
         bailout 1
      fi

      # move fai logs into grml_logs directory
      mkdir -p "$LOG_OUTPUT"/fai/
      cp -r "$CHROOT_OUTPUT"/var/log/fai/"$HOSTNAME"/last/* "$LOG_OUTPUT"/fai/
      rm -rf "$CHROOT_OUTPUT"/var/log/fai
      # copy fai package list
      cp "$CHROOT_OUTPUT"/var/log/install_packages.list "$LOG_OUTPUT"/fai/
      # fixup owners
      chown root:adm "$LOG_OUTPUT"/fai/*
      chmod 664 "$LOG_OUTPUT"/fai/*

      umount_all

      # notice: 'fai dirinstall' does not seem to exit appropriate, so:
      ERROR=''
      CHECKLOG="$LOG_OUTPUT"/fai/
      if [ -r "$CHECKLOG/software.log" ] ; then
         # 1 errors during executing of commands
         grep 'dpkg: error processing' $CHECKLOG/software.log >> $LOGFILE && ERROR=1
         grep 'E: Method http has died unexpectedly!' $CHECKLOG/software.log >> $LOGFILE && ERROR=2
         grep 'ERROR: chroot' $CHECKLOG/software.log >> $LOGFILE && ERROR=3
         grep 'E: Failed to fetch' $CHECKLOG/software.log >> $LOGFILE && ERROR=4
         grep 'Unable to write mmap - msync (28 No space left on device)' $CHECKLOG/software.log >> $LOGFILE && ERROR=5
      fi

      if [ -r "$CHECKLOG/shell.log" ] ; then
         grep 'FAILED with exit code' $CHECKLOG/shell.log >> $LOGFILE && ERROR=6
      fi

      if [ -n "$ERROR" ] ; then
         log    "Error: there was a critical error [${ERROR}] during execution of stage 'fai dirinstall' [$(date)]"
         eerror "Error: there was a critical error during execution of stage 'fai dirinstall'"
         eerror "Note:  check out ${CHECKLOG}/ for details. [exit ${ERROR}]"
         eend 1
         bailout 1
      else
         log "Finished execution of stage 'fai dirinstall' [$(date)]"
         einfo "Finished execution of stage 'fai dirinstall'"
      fi
   fi
fi # BUILD_DIRTY?
# }}}

# package validator {{{
CHECKLOG=/var/log/fai/$HOSTNAME/last
if [ -r "$CHECKLOG/dpkg.selections" ] ; then
  package_count=$(wc -l "$CHECKLOG/dpkg.selections" | awk '{print $1}')
else
  package_count="unknown"
fi

mkdir -p "$REPORTS"
REPORT_MISSING_PACKAGES="${REPORTS}/TEST-MissingPackages.xml"

# check for missing packages
if ! [ -s "$CHECKLOG/package_errors.log" ] ; then
  einfo "No missing packages found, generating empty junit report."

  cat > "${REPORT_MISSING_PACKAGES}" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<testsuite name="grml-live-missing-packages" tests="${package_count}" time="1" failures="0" errors="0" skipped="0" assertions="0">
  <testcase name="test_missing_packages" time="0" assertions="0">
  </testcase>
  <system-out>
  </system-out>
  <system-err>
  </system-err>
</testsuite>
EOF
  eend 0
else
  einfo "Missing packages found, generating junit report."

  if [ -r "$CHECKLOG/package_errors.log" ] ; then
    package_errors=$(wc -l "$CHECKLOG/package_errors.log" | awk '{print $1}')
  else
    package_errors="unknown"
  fi

  mkdir -p "$REPORTS"
  REPORT_MISSING_PACKAGES="${REPORTS}/TEST-MissingPackages.xml"

  cat > "${REPORT_MISSING_PACKAGES}" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<testsuite name="grml-live-missing-packages" tests="${package_count}" time="1" failures="${package_errors}" errors="${package_errors}" skipped="0" assertions="0">
EOF

  for package in $(awk '{print $5}' "${CHECKLOG}/package_errors.log" | sed 's/\.$//') ; do
    cat >> "${REPORT_MISSING_PACKAGES}" << EOF
  <testcase name="test_missing_packages_${package}" time="0" assertions="0">
    <failure type="RuntimeError" message="Package ${package} is missing">
Package $package is missing in chroot
  </failure>
  </testcase>
EOF
  done

  cat >> "${REPORT_MISSING_PACKAGES}" << EOF
  <system-out>
  </system-out>
  <system-err>
  </system-err>
</testsuite>
EOF
  eend 0

  if [ -n "$EXIT_ON_MISSING_PACKAGES" -a -z "$BUILD_DIRTY" ] ; then
    eerror "The following packages were requested for installation but could not be processed:"
    cat "$CHECKLOG/package_errors.log"
    eerror "... exiting as requested via \$EXIT_ON_MISSING_PACKAGES."
    eend 1
    bailout 13
  else
    ewarn "The following packages were requested for installation but could not be processed:"
    cat "$CHECKLOG/package_errors.log"
    eend 0
  fi
fi
# }}}

# BUILD_OUTPUT - execute arch specific stuff and squashfs {{{
[ -n "$BUILD_OUTPUT" ] || BUILD_OUTPUT="$OUTPUT/grml_cd"
mkdir -p "$BUILD_OUTPUT" || bailout 6 "Problem with creating $BUILD_OUTPUT for stage ARCH"

# prepare ISO
if [ "$ARCH" = i386 ] || [ "$ARCH" = amd64 ] ; then
  if [ -n "$BOOTSTRAP_ONLY" ] ; then
     log   "Skipping stage 'boot' as building with bootstrap only."
     ewarn "Skipping stage 'boot' as building with bootstrap only." ; eend 0
  else
    if [ -d "$BUILD_OUTPUT"/boot/isolinux -a -z "$UPDATE" -a -z "$BUILD_ONLY" ] ; then
       log   "Skipping stage 'boot' as $BUILD_OUTPUT/boot/isolinux exists already."
       ewarn "Skipping stage 'boot' as $BUILD_OUTPUT/boot/isolinux exists already." ; eend 0
    else
       # booting stuff:
       [ -d "$BUILD_OUTPUT"/boot/isolinux ] || mkdir -p "$BUILD_OUTPUT"/boot/isolinux
       [ -d "$BUILD_OUTPUT"/boot/"${SHORT_NAME}" ] || mkdir -p "$BUILD_OUTPUT"/boot/"${SHORT_NAME}"

       # if we don't have an initrd we a) can't boot and b) there was an error
       # during build, so check for the file:
       INITRD="$(ls $CHROOT_OUTPUT/boot/initrd* 2>/dev/null| grep -v '.bak$' | sort -r | head -1)"
       if [ -n "$INITRD" ] ; then
          cp $INITRD "$BUILD_OUTPUT"/boot/"${SHORT_NAME}"/initrd.gz
          find $CHROOT_OUTPUT/boot/ -name initrd\*.bak -exec rm {} \;
       else
          log    "Error: No initrd found inside $CHROOT_OUTPUT/boot/ - Exiting"
          eerror "Error: No initrd found inside $CHROOT_OUTPUT/boot/ - Exiting" ; eend 1
          bailout 10
       fi

       KERNEL_IMAGE="$(ls $CHROOT_OUTPUT/boot/vmlinuz* 2>/dev/null | sort -r | head -1)"
       if [ -n "$KERNEL_IMAGE" ] ; then
          cp "$KERNEL_IMAGE" "$BUILD_OUTPUT"/boot/"${SHORT_NAME}"/linux26
       else
          log    "Error: No kernel found inside $CHROOT_OUTPUT/boot/ - Exiting"
          eerror "Error: No kernel found inside $CHROOT_OUTPUT/boot/ - Exiting" ; eend 1
          bailout 11
       fi

       [ -n "$TEMPLATE_DIRECTORY" ] || TEMPLATE_DIRECTORY='/usr/share/grml-live/templates'
       if ! [ -d "${TEMPLATE_DIRECTORY}"/boot ] ; then
          log    "Error: ${TEMPLATE_DIRECTORY}/boot does not exist. Exiting."
          eerror "Error: ${TEMPLATE_DIRECTORY}/boot does not exist. Exiting." ; eend 1
          bailout 8
       fi

       # copy _required_ isolinux files
       for file in ifcpu64.c32 isolinux.bin vesamenu.c32; do
         copy_addon_file "${file}" /usr/lib/syslinux isolinux
       done

       # *always* copy files to output directory so the variables
       # get adjusted according to the build.
       cp ${TEMPLATE_DIRECTORY}/boot/isolinux/*  "$BUILD_OUTPUT"/boot/isolinux/

       if [ -n "$NO_ADDONS" ] ; then
          log   "Skipping installation of boot addons as requested via \$NO_ADDONS."
          einfo "Skipping installation of boot addons as requested via \$NO_ADDONS."; eend 0
       else
          if ! [ -d "$TEMPLATE_DIRECTORY"/boot/addons ] ; then
            log   "Boot addons not found, skipping therefore. (Consider installing package grml-live-addons)"
            ewarn "Boot addons not found, skipping therefore. (Consider installing package grml-live-addons)" ; eend 0
          else
            # copy addons from system packages or grml-live-compat
            copy_addon_file ipxe.lkrn /usr/lib/ipxe addons
            copy_addon_file pci.ids /usr/share/misc addons
            copy_addon_file memtest86+.bin /boot addons
            for file in memdisk chain.c32 hdt.c32 menu.c32; do
              copy_addon_file "${file}" /usr/lib/syslinux addons
            done

            # make memtest filename FAT16/8.3 compatible
            mv "${BUILD_OUTPUT}/boot/addons/memtest86+.bin" \
              "${BUILD_OUTPUT}/boot/addons/memtest"

            # copy only files so we can handle bsd4grml on its own
            for file in ${TEMPLATE_DIRECTORY}/boot/addons/* ; do
              test -f $file && cp $file "$BUILD_OUTPUT"/boot/addons/
            done

            if [ -n "$NO_ADDONS_BSD4GRML" ] ; then
               log   "Skipping installation of bsd4grml as requested via \$NO_ADDONS_BSD4GRML."
               einfo "Skipping installation of bsd4grml as requested via \$NO_ADDONS_BSD4GRML."; eend 0
            else
               if [ -d "$TEMPLATE_DIRECTORY"/boot/addons/bsd4grml ] ; then
                 cp -a ${TEMPLATE_DIRECTORY}/boot/addons/bsd4grml "$BUILD_OUTPUT"/boot/addons/
               else
                 log   "Missing addon file: bsd4grml"
                 ewarn "Missing addon file: bsd4grml" ; eend 0
               fi
            fi

          fi # no "$TEMPLATE_DIRECTORY"/boot/addons
       fi # NO_ADDONS

       if ! [ -d "${BUILD_OUTPUT}/boot/grub" ] ; then
         mkdir -p "${BUILD_OUTPUT}/boot/grub"
       fi
       cp ${TEMPLATE_DIRECTORY}/boot/grub/* "$BUILD_OUTPUT"/boot/grub/

       # copy grub files from target
       cp -a "${CHROOT_OUTPUT}"/usr/lib/grub/*-pc/*.mod "${BUILD_OUTPUT}"/boot/grub/
       cp -a "${CHROOT_OUTPUT}"/usr/lib/grub/*-pc/*.o "${BUILD_OUTPUT}"/boot/grub/
       cp -a "${CHROOT_OUTPUT}"/usr/lib/grub/*-pc/*.lst "${BUILD_OUTPUT}"/boot/grub/
       cp -a "${CHROOT_OUTPUT}"/usr/share/grub/ascii.pf2 "${BUILD_OUTPUT}"/boot/grub/
       cp -a "${CHROOT_OUTPUT}"/boot/grub/core.img "${BUILD_OUTPUT}"/boot/grub/

       if ! [ -d "${TEMPLATE_DIRECTORY}"/GRML ] ; then
          log    "Error: ${TEMPLATE_DIRECTORY}/GRML does not exist. Exiting."
          eerror "Error: ${TEMPLATE_DIRECTORY}/GRML does not exist. Exiting." ; eend 1
          bailout 9
       fi

       [ -d "$BUILD_OUTPUT"/GRML ] || mkdir "$BUILD_OUTPUT"/GRML
       cp -a ${TEMPLATE_DIRECTORY}/GRML/* "$BUILD_OUTPUT"/GRML/

       # adjust boot splash information:
       RELEASE_INFO="$GRML_NAME $VERSION - Release Codename $RELEASENAME"
       RELEASE_INFO="$(cut_string 68 "$RELEASE_INFO")"
       RELEASE_INFO="$(extend_string_end 68 "$RELEASE_INFO")"

       if [ -r "$BUILD_OUTPUT"/GRML/grml-version ] ; then
          sed -i "s/%RELEASE_INFO%/$GRML_NAME $VERSION - $RELEASENAME/" "$BUILD_OUTPUT"/GRML/grml-version
          sed -i "s/%DATE%/$DATE/"                                      "$BUILD_OUTPUT"/GRML/grml-version
       fi

       # make sure the squashfs filename is set accordingly:
       SQUASHFS_NAME="$GRML_NAME.squashfs"

       if [ -n "$NO_BOOTID" ] ; then
          log   'Skipping bootid feature as requested via $NO_BOOTID.'
          einfo 'Skipping bootid feature as requested via $NO_BOOTID.'
       else
          [ -n "$BOOTID" ] || BOOTID="$(echo ${GRML_NAME}${VERSION} | tr -d ',./;\- ')"
          [ -d "$BUILD_OUTPUT"/conf ] || mkdir "$BUILD_OUTPUT"/conf
          einfo "Generating /conf/bootid.txt with entry ${BOOTID}."
          log   "Generating /conf/bootid.txt with entry ${BOOTID}."
          echo "$BOOTID" > "$BUILD_OUTPUT"/conf/bootid.txt
          eend $?
       fi

       # adjust all variables in the templates with the according distribution information
       for file in "${BUILD_OUTPUT}"/boot/isolinux/*.cfg "${BUILD_OUTPUT}"/boot/isolinux/*.msg \
                   "${BUILD_OUTPUT}"/boot/grub/* ; do
         if [ -r "${file}" ] ; then
           sed -i "s/%ARCH%/$ARCH/g"                    "${file}"
           sed -i "s/%DATE%/$DATE/g"                    "${file}"
           sed -i "s/%DISTRI_INFO%/$DISTRI_INFO/g"      "${file}"
           sed -i "s/%DISTRI_NAME%/$DISTRI_NAME/g"      "${file}"
           sed -i "s/%DISTRI_SPLASH%/$DISTRI_SPLASH/g"  "${file}"
           sed -i "s/%GRML_NAME%/$GRML_NAME/g"          "${file}"
           sed -i "s/%SQUASHFS_NAME%/$SQUASHFS_NAME/g"  "${file}"
           sed -i "s/%RELEASE_INFO%/$RELEASE_INFO/g"    "${file}"
           sed -i "s/%SHORT_NAME%/$SHORT_NAME/g"        "${file}"
           sed -i "s/%VERSION%/$VERSION/g"              "${file}"

           [ -n "$DEFAULT_BOOTOPTIONS" ] && sed -i "s/ boot=live/ boot=live $DEFAULT_BOOTOPTIONS/"  "${file}"

           if [ -n "$NO_BOOTID" ] ; then
              sed -i "s/ bootid=%BOOTID%//g" "${file}" # drop bootid bootoption
           else
              sed -i "s/%BOOTID%/$BOOTID/g" "${file}" # adjust bootid=... argument
           fi
         fi
       done

       # adjust bootsplash accordingly but make sure the string has the according lenght
       SQUASHFS_NAME="$(cut_string 20 "$SQUASHFS_NAME")"
       SQUASHFS_NAME="$(extend_string_end 20 "$SQUASHFS_NAME")"
       for file in f4 f5 ; do
          if [ -r "${BUILD_OUTPUT}/boot/isolinux/${file}" ] ; then
             sed -i "s/%SQUASHFS_NAME%/$SQUASHFS_NAME/" "${BUILD_OUTPUT}/boot/isolinux/${file}"
             sed -i "s/%SQUASHFS_NAME%/$SQUASHFS_NAME/" "${BUILD_OUTPUT}/boot/isolinux/${file}"
          fi
       done

       # generate addon list
       rm -f "${BUILD_OUTPUT}/${ADDONS_LIST_FILE}"
       for name in "${BUILD_OUTPUT}"/boot/isolinux/addon_*.cfg ; do
         include_name=$(basename "$name")
         echo "include $include_name"  >> "${BUILD_OUTPUT}/${ADDONS_LIST_FILE}"
       done

       if ! [ -r "${BUILD_OUTPUT}/boot/isolinux/${DISTRI_NAME}.cfg" ] || [ "$DISTRI_NAME" = "grml" ] ; then
          log "including grmlmain.cfg in ${BUILD_OUTPUT}/boot/isolinux/distri.cfg"
          echo "include grmlmain.cfg"    >  "${BUILD_OUTPUT}/boot/isolinux/distri.cfg"
          echo "include default.cfg"     >  "${BUILD_OUTPUT}/boot/isolinux/grmlmain.cfg"
          echo "include menuoptions.cfg" >> "${BUILD_OUTPUT}/boot/isolinux/grmlmain.cfg"
          echo "include grml.cfg"        >> "${BUILD_OUTPUT}/boot/isolinux/grmlmain.cfg"

          for f in "${BUILD_OUTPUT}"/boot/isolinux/submenu*.cfg ; do
            echo "include $(basename $f)"     >> "${BUILD_OUTPUT}/boot/isolinux/grmlmain.cfg"
          done

          echo "include options.cfg"     >> "${BUILD_OUTPUT}/boot/isolinux/grmlmain.cfg"
          if [ ! -n "$NO_ADDONS" ] ; then
            echo "include addons.cfg"    >> "${BUILD_OUTPUT}/boot/isolinux/grmlmain.cfg"
          fi
          echo "include isoprompt.cfg"   >> "${BUILD_OUTPUT}/boot/isolinux/grmlmain.cfg"
          echo "include hd.cfg"          >> "${BUILD_OUTPUT}/boot/isolinux/grmlmain.cfg"
          echo "include hidden.cfg"      >> "${BUILD_OUTPUT}/boot/isolinux/grmlmain.cfg"
       else # assume we are building a custom distribution:
          log "File ${BUILD_OUTPUT}/boot/isolinux/${DISTRI_NAME}.cfg found, using it."
          einfo "File ${BUILD_OUTPUT}/boot/isolinux/${DISTRI_NAME}.cfg found, using it."
          if grep -q "^include ${DISTRI_NAME}.cfg" "${BUILD_OUTPUT}/boot/isolinux/distri.cfg" ; then
            log "include for ${DISTRI_NAME}.cfg already present, nothing to do."
            eindent
            einfo "include for ${DISTRI_NAME}.cfg already present, nothing to do."
            eoutdent
            eend $?
         else
            log "including ${DISTRI_NAME}.cfg in ${BUILD_OUTPUT}/boot/isolinux/distri.cfg"
            echo "include ${DISTRI_NAME}.cfg" > "${BUILD_OUTPUT}/boot/isolinux/distri.cfg"
            [ -n "$NO_ADDONS" ] || echo "include addons.cfg" >> "${BUILD_OUTPUT}/boot/isolinux/distri.cfg"
          fi
       fi

       # use old style console based isolinux method only if requested:
       if [[ "${ISOLINUX_METHOD}" == "console" ]] ; then
          log 'Using console based isolinux method as requested via $ISOLINUX_METHOD.'
          einfo 'Using console based isolinux method as requested via $ISOLINUX_METHOD.'
          if grep -q '^include console.cfg' "${BUILD_OUTPUT}/boot/isolinux/distri.cfg" ; then
            einfo "include for console.cfg already found, nothing to do."
            eend 0
          else
            log "including console.cfg in ${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg"
            einfo "including console.cfg in ${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg"
            echo "include console.cfg" >> "${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg"
            eend $?
          fi
       else
          log 'Using graphical boot menu.'
          if grep -q '^include vesamenu.cfg' "${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg" ; then
            log "include for vesamenu.cfg already found, nothing to do."
          else
            log "including vesamenu.cfg in ${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg"
            echo "include vesamenu.cfg" >> "${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg"
          fi
       fi

       if [ -e "$BUILD_OUTPUT"/boot/addons/bsd4grml/boot.6 ]; then
          sed -i "s/%RELEASE_INFO%/$GRML_NAME $VERSION - $RELEASENAME/" "$BUILD_OUTPUT"/boot/addons/bsd4grml/boot.6
       fi

       DPKG_LIST="/var/log/fai/$HOSTNAME/last/dpkg.list" # the dpkg --list output of the chroot
       if ! [ -r "$DPKG_LIST" ] ; then
          ewarn "$DPKG_LIST could not be read, ignoring to store package information on ISO therefore."
       else
          einfo "Storing package list information as /GRML/${GRML_NAME}-packages.txt on ISO."
          cp "$DPKG_LIST" "${BUILD_OUTPUT}/GRML/${GRML_NAME}-packages.txt"
          eend $?
       fi

       # autostart for Windows:
       if [ -d "${TEMPLATE_DIRECTORY}/windows/autostart/" ] ; then
          cp ${TEMPLATE_DIRECTORY}/windows/autostart/* "$BUILD_OUTPUT"/
       fi

    FORCE_ISO_REBUILD=true
    einfo "Finished execution of stage 'boot'" ; eend 0
    fi
  fi # BOOTSTRAP_ONLY
else
   log    'Error: Unsupported ARCH, sorry. Want to support it? Contribute!'
   eerror 'Error: Unsupported ARCH, sorry. Want to support it? Contribute!' ; eend 1
   bailout
fi

# support installation of local files into the chroot/ISO
if [ -n "$CHROOT_INSTALL" ] ; then
  if ! [ -d "$CHROOT_INSTALL" ] ; then
     log "Configuration variable \$CHROOT_INSTALL is set but not a directory; ignoring"
     ewarn "Configuration variable \$CHROOT_INSTALL is set but not a directory; ignoring"
  else
     log "Copying local files to chroot as requested via \$CHROOT_INSTALL"
     einfo "Copying local files to chroot as requested via \$CHROOT_INSTALL"
     rsync -avz --inplace "$CHROOT_INSTALL"/ "$CHROOT_OUTPUT/"
     eend $?
     einfo "Make sure to run squashfs stage, otherwise your local files won't be part of the ISO."
     FORCE_ISO_REBUILD=true
  fi
fi

if [ -f "$BUILD_OUTPUT"/live/${GRML_NAME}.squashfs -a -z "$UPDATE" -a -z "$BUILD_ONLY" -a -z "$BUILD_DIRTY" ] ; then
   log   "Skipping stage 'squashfs' as $BUILD_OUTPUT/live exists already."
   ewarn "Skipping stage 'squashfs' as $BUILD_OUTPUT/live exists already." ; eend 0
elif [ -n "$SKIP_MKSQUASHFS" ] ; then
   log   "Skipping stage 'squashfs' as requested via option -q or -N"
   ewarn "Skipping stage 'squashfs' as requested via option -q or -N" ; eend 0
else
   [ -d "$BUILD_OUTPUT"/live ] || mkdir "$BUILD_OUTPUT"/live
   # make sure we don't leave (even an empty) base.tgz:
   [ -f "$CHROOT_OUTPUT/base.tgz" ] && rm -f "$CHROOT_OUTPUT/base.tgz"

   # if unconfigured default to squashfs-tools' mksquashfs binary
   if [ -z "$SQUASHFS_BINARY" ] ; then
      SQUASHFS_BINARY='mksquashfs'
   fi

   if which "$SQUASHFS_BINARY" >/dev/null 2>&1 ; then
      log    "Using mksquashfs binary ${SQUASHFS_BINARY}"
      einfo  "Using mksquashfs binary ${SQUASHFS_BINARY}" ; eend 0
   else
      log    "Error: mksquashfs binary ($SQUASHFS_BINARY) not found. Exiting."
      eerror "Error: mksquashfs binary ($SQUASHFS_BINARY) not found. Exiting." ; eend 1
      bailout
   fi

   # use sane defaults if $SQUASHFS_OPTIONS isn't set
   if [ -z "$SQUASHFS_OPTIONS" ] ; then
     # use blocksize 256k as this gives best result with regards to time + compression
     SQUASHFS_OPTIONS="-b 256k"

     # set lzma/xz compression by default, unless -z option has been specified on command line
     if [ -z "$SQUASHFS_ZLIB" ] ; then
        SQUASHFS_OPTIONS="$SQUASHFS_OPTIONS -comp xz"
     else
        SQUASHFS_OPTIONS="$SQUASHFS_OPTIONS -comp gzip"
     fi
   fi

   # support exclusion of files via exclude-file:
   if [ -n "$SQUASHFS_EXCLUDES_FILE" -a "$SQUASHFS_EXCLUDES_FILE" ] ; then
      SQUASHFS_OPTIONS="$SQUASHFS_OPTIONS -ef $SQUASHFS_EXCLUDES_FILE -wildcards"
   fi

   # get rid of unnecessary files when building grml-small for final release:
   if echo "$CLASSES" | grep -q GRML_SMALL ; then
      SQUASHFS_OPTIONS="$SQUASHFS_OPTIONS -e initrd.img* vmlinuz*"
   fi

   # log stuff
   SQUASHFS_STDERR="$(mktemp -t grml-live.XXXXXX)"

   # informational stuff
   [ -n "$SQUASHFS_OPTIONS" ]  && SQUASHFS_INFO_MSG="$SQUASHFS_OPTIONS"
   [ -n "$SQUASHFS_INFO_MSG" ] && SQUASHFS_INFO_MSG="using options: $SQUASHFS_INFO_MSG"
   einfo "Squashfs build information: running binary $SQUASHFS_BINARY $SQUASHFS_INFO_MSG"

   log "$SQUASHFS_BINARY $CHROOT_OUTPUT/ $BUILD_OUTPUT/live/${GRML_NAME}.squashfs -noappend $SQUASHFS_OPTIONS"

   if $SQUASHFS_BINARY $CHROOT_OUTPUT/ $BUILD_OUTPUT/live/"${GRML_NAME}".squashfs \
      -noappend $SQUASHFS_OPTIONS 2>"${SQUASHFS_STDERR}" ; then
      echo "${GRML_NAME}.squashfs" > $BUILD_OUTPUT/live/filesystem.module
      log "Finished execution of stage 'squashfs' [$(date)]"
      einfo "Finished execution of stage 'squashfs'" ; eend 0
   else
      log    "Error: there was a critical error executing stage 'squashfs' [$(date)]:"
      log    "$(cat $SQUASHFS_STDERR)"
      eerror "Error: there was a critical error executing stage 'squashfs':"
      cat    "${SQUASHFS_STDERR}"
      eend 1
      bailout
   fi

   FORCE_ISO_REBUILD=true
fi

# create md5sum file:
if [ -z "$BOOTSTRAP_ONLY" ] ; then
  ( cd $BUILD_OUTPUT/GRML &&
  find .. -type f -not -name md5sums -not -name isolinux.bin -exec md5sum {} \; > md5sums )
fi
# }}}

# ISO_OUTPUT - mkisofs {{{
[ -n "$ISO_OUTPUT" ] || ISO_OUTPUT="$OUTPUT/grml_isos"
[ -n "$ISO_NAME" ] || ISO_NAME="${GRML_NAME}_${VERSION}.iso"

if [ "$BOOT_METHOD" = "isolinux" ] ; then
   BOOT_ARGS="-no-emul-boot -boot-load-size 4 -boot-info-table -b boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat"
elif [ "$BOOT_METHOD" = "grub2" ] ; then
   BOOT_ARGS="-no-emul-boot -boot-load-size 4 -b boot/grub/toriboot.bin"
fi

# Just until http://bts.grml.org/grml/issue945 has been resolved.
# HYBRID_METHOD defaults to manifold, so make sure the default works OOTB.
if [[ $BOOT_METHOD != isolinux && ($HYBRID_METHOD = isohybrid || $HYBRID_METHOD = manifold) ]]; then
  log   "Setting HYBRID_METHOD to grub2 as hybrid mode does not work with isohybrid yet."
  ewarn "Setting HYBRID_METHOD to grub2 as hybrid mode does not work with isohybrid yet."
  HYBRID_METHOD='grub2'
  eend 0
fi

if [ -f "${ISO_OUTPUT}/${ISO_NAME}" -a -z "$UPDATE" -a -z "$BUILD_ONLY" -a -z "$BUILD_DIRTY" -a "$FORCE_ISO_REBUILD" = "false" ]  ; then
   log   "Skipping stage 'iso build' as $ISO_OUTPUT/${ISO_NAME} exists already."
   ewarn "Skipping stage 'iso build' as $ISO_OUTPUT/${ISO_NAME} exists already." ; eend 0
elif [ -n "$SKIP_MKISOFS" ] ; then
   log   "Skipping stage 'iso build' as requested via option -n or -N"
   ewarn "Skipping stage 'iso build' as requested via option -n or -N" ; eend 0
else
   mkdir -p "$ISO_OUTPUT" || bailout 6 "Problem with creating $ISO_OUTPUT for stage 'iso build'"

   if $FORCE_ISO_REBUILD && ! [ -f "${ISO_OUTPUT}/${ISO_NAME}" ] ; then
      log   "Forcing rebuild of ISO because files on ISO have been modified."
      einfo "Forcing rebuild of ISO because files on ISO have been modified."
   fi

   # support xorriso as well mkisofs and genisoimage
   if which xorriso >/dev/null 2>&1 ; then
      MKISOFS='xorriso -as mkisofs'
    elif which mkisofs >/dev/null 2>&1; then
      MKISOFS='mkisofs'
   elif which genisoimage >/dev/null 2>&1; then
      MKISOFS='genisoimage'
   else
      log    "Error: neither xorriso nor mkisofs nor genisoimage available - can not create ISO."
      eerror "Error: neither xorriso nor mkisofs nor genisoimage available - can not create ISO." ; eend 1
      bailout
   fi

   case "$ARCH" in
     amd64)
       # using -eltorito-alt-boot is limited to xorriso for now
       case "$MKISOFS" in
         xorriso*)
           einfo "Using xorriso for ISO generation." ;  eend 0
           eindent

           if ! dpkg --compare-versions $(dpkg-query -W -f='${Version}\n' xorriso 2>/dev/null) gt-nl 1.1.6-1 ; then
             log   "Disabling (U)EFI boot support since xorriso version is not recent enough."
             ewarn "Disabling (U)EFI boot support since xorriso version is not recent enough." ; eend 0
           else
             log   "xorriso with -eltorito-alt-boot present, enabling (U)EFI boot support."
             einfo "xorriso with -eltorito-alt-boot present, enabling (U)EFI boot support." ; eend 0

             if [ -r "${CHROOT_OUTPUT}/var/lib/grml_live_efi.img" ] ; then
               einfo "Found /var/lib/grml_live_efi.img - moving to /boot/efi.img for ISO."
               log   "Found /var/lib/grml_live_efi.img - moving to /boot/efi.img for ISO."
               mv "${CHROOT_OUTPUT}/var/lib/grml_live_efi.img" "${BUILD_OUTPUT}/boot/efi.img"
               eend $?
             fi

             if [ -r "${CHROOT_OUTPUT}/var/lib/grml_live_bootx64.efi" ] ; then
               einfo "Found /var/lib/grml_live_bootx64.efi - moving to /efi/boot/bootx64.efi for ISO"
               log   "Found /var/lib/grml_live_bootx64.efi - moving to /efi/boot/bootx64.efi for ISO"
               mkdir -p "${BUILD_OUTPUT}/efi/boot/"
               mv "${CHROOT_OUTPUT}/var/lib/grml_live_bootx64.efi" "${BUILD_OUTPUT}/efi/boot/bootx64.efi"
               eend $?
             fi

             if [ -r "${BUILD_OUTPUT}"/boot/efi.img ] ; then
               einfo "/boot/efi.img found and amd64 architecture present, extending boot arguments."
               log   "/boot/efi.img found and amd64 architecture present, extending boot arguments."
               BOOT_ARGS="$BOOT_ARGS -boot-info-table -eltorito-alt-boot -e boot/efi.img -no-emul-boot"
               eend $?
             fi
           fi

           eoutdent
           ;;
       esac
       ;;
   esac

   CURRENT_DIR=$(pwd)
   if cd "$BUILD_OUTPUT" ; then
      if [ "$BOOT_METHOD" = "grub2" ]; then
         # make a 2048-byte bootsector for El Torito
         dd if=/dev/zero of=boot/grub/toriboot.bin bs=512 count=4 2>/dev/null
         # those are in 2048-byte sectors, so 1 16 matches 4 63 below
         echo 1 16 | mksh /usr/share/grml-live/scripts/bootgrub.mksh -B 11 | \
            dd of=boot/grub/toriboot.bin conv=notrunc 2>/dev/null
      fi
      log "$MKISOFS -V '${GRML_NAME} ${VERSION}' -publisher 'grml-live | grml.org' -l -r -J $BOOT_ARGS -o ${ISO_OUTPUT}/${ISO_NAME} ."
      $MKISOFS -V "${GRML_NAME} ${VERSION}" -publisher 'grml-live | grml.org' \
              -l -r -J $BOOT_ARGS -no-pad \
              -o "${ISO_OUTPUT}/${ISO_NAME}" . ; RC=$?
      # both of these need core.img there, so it’s easier to write it here
      if [ "$BOOT_METHOD" = "grub2" ] || [ "$HYBRID_METHOD" = "grub2" ]; then
         # must be <= 30720 bytes
         dd if=boot/grub/core.img of="${ISO_OUTPUT}/${ISO_NAME}" \
           conv=notrunc bs=512 seek=4 2>/dev/null
      fi

      # pad the output ISO to multiples of 256 KiB for partition table support
      siz=$($getfilesize "${ISO_OUTPUT}/${ISO_NAME}")
      cyls=$((siz / 512 / 32 / 16 + 1))   # C=$cyls H=16 S=32
      siz=$((cyls * 16 * 32 * 512))   # size after padding
      dd if=/dev/zero bs=1 count=1 seek=$((siz - 1)) \
         of="${ISO_OUTPUT}/${ISO_NAME}" 2>/dev/null

      # support disabling hybrid ISO image
      if [ "$HYBRID_METHOD" = "disable" ] ; then\
         log   "Skipping creation of hybrid ISO file as requested via HYBRID_METHOD=disable"
         einfo "Skipping creation of hybrid ISO file as requested via HYBRID_METHOD=disable"
         eend 0
      elif [ "$HYBRID_METHOD" = "manifold" ] ; then
         # isoinfo is part of both mkisofs and genisoimage so we're good
         bootoff=$(isoinfo -l -i "${ISO_OUTPUT}/${ISO_NAME}" | \
           sed -n '/^.*\[ *\([0-9]*\)[] ].* ISOLINUX.BIN[;1]* *$/s//\1/p')
         if ! [ -r boot/grub/core.img ] ; then
           ewarn "boot/grub/core.img not found, not creating manifold boot ISO file"
         elif [ "${bootoff:-0}" -lt 1 ] ; then
           ewarn "isolinux.bin not found on the ISO file, disabling manifold boot"
         else
           log "Creating hybrid ISO file with manifold method"
           einfo "Creating hybrid ISO file with manifold method"
           if [ "$HYBRID_METHOD" = "grub2" ] ; then
               # 512 bytes: MBR, partition table, load GRUB 2
               echo 4 63 | mksh /usr/share/grml-live/scripts/bootgrub.mksh -A -M 4:0x96 -g $cyls:16:32
           else
              # read only one but 2048-byte sized (scale: << 2) sector
              echo $bootoff $bootoff | \
                 mksh /usr/share/grml-live/scripts/bootilnx.mksh -A -M 4:0x96 -g $cyls:16:32 -S 2
           fi | dd of="${ISO_OUTPUT}/${ISO_NAME}" conv=notrunc 2>/dev/null
           eend $?
         fi
      # use isohybrid as default
      else
         if ! which isohybrid >/dev/null 2>&1 ; then
           bailout 12 "isohybrid binary not found - please install syslinux/syslinux-common"
         else
           log   "Creating hybrid ISO file with isohybrid method"
           einfo "Creating hybrid ISO file with isohybrid method"
           # Notes for consideration:
           # "-entry 4 -type 1c"
           # * using 4 as the partition number is supposed to help with BIOSes
           #   that only support USB-Zip boot
           # * using 1c (i.e. hidden FAT32 LBA), instead of the default 0x17
           #   (hidden NTFS, IIRC), as the partition type is sometimes needed
           #   to get the BIOS even look at the partition created by isohybrid
           if isohybrid --help | grep -q -- --uefi ; then
             einfo "Detected uefi support for isohybrid, enabling."
             ISOHYBRID_OPTIONS=--uefi
           fi

           log "isohybrid $ISOHYBRID_OPTIONS ${ISO_OUTPUT}/${ISO_NAME}"
           isohybrid $ISOHYBRID_OPTIONS "${ISO_OUTPUT}/${ISO_NAME}"
           eend $?
         fi
      fi

      # generate md5sum and sha1sum of ISO if we are using class 'RELEASE':
      case $CLASSES in *RELEASE*)
         [ "$RC" = 0 ] && \
         (
           if cd $ISO_OUTPUT ; then
             md5sum ${ISO_NAME} > ${ISO_NAME}.md5 && \
             touch -r ${ISO_NAME} ${ISO_NAME}.md5
             sha1sum ${ISO_NAME} > ${ISO_NAME}.sha1 && \
             touch -r ${ISO_NAME} ${ISO_NAME}.sha1
           fi
         )
         ;;
      esac

      cd "$CURRENT_DIR"
   fi

   if [ "$RC" = 0 ] ; then
      log   "Finished execution of stage 'iso build' [$(date)]"
      einfo "Finished execution of stage 'iso build'" ; eend 0
   else
      log    "Error: there was a critical error ($RC) executing stage 'iso build' [$(date)]"
      eerror "Error: there was a critical error executing stage 'iso build'" ; eend 1
      bailout $RC
   fi
fi
# }}}

# netboot package {{{
create_netbootpackage() {
  local OUTPUT_FILE="${NETBOOT}/grml_netboot_package_${GRML_NAME}_${VERSION}.tar.bz2"

  if [ -f "${OUTPUT_FILE}" -a -z "$UPDATE" -a -z "$BUILD_ONLY" -a -z "$BUILD_DIRTY" ] ; then
    log   "Skipping stage 'netboot' as $OUTPUT_FILE exists already."
    ewarn "Skipping stage 'netboot' as $OUTPUT_FILE exists already." ; eend 0
    return 0
  elif [ -n "$SKIP_NETBOOT" ] ; then
    log   "Skipping stage 'netboot' as requested via option -Q"
    ewarn "Skipping stage 'netboot' as requested via option -Q" ; eend 0
    return 0
  fi

  mkdir -p "$NETBOOT"

  if ! [ -r "${CHROOT}/usr/lib/syslinux/pxelinux.0" ] ; then
    ewarn "File /usr/lib/syslinux/pxelinux.0 not found in build chroot." ; eend 0
    eindent
    einfo "Install syslinux[-common] package in chroot to get a netboot package."
    eoutdent
    return 0
  fi

  local OUTPUTDIR="${NETBOOT}/build_tmp"
  local WORKING_DIR="${OUTPUTDIR}/grml_netboot_package_${GRML_NAME}_${VERSION}/tftpboot/"

  mkdir -p "$WORKING_DIR"

  cp "${CHROOT_OUTPUT}"/boot/vmlinuz-*    "$WORKING_DIR"/linux26
  cp "${CHROOT_OUTPUT}"/boot/initrd.img-* "$WORKING_DIR"/initrd.img
  cp "${CHROOT_OUTPUT}"/usr/lib/syslinux/pxelinux.0 "${WORKING_DIR}/pxelinux.0"

  if [ -r "${BUILD_OUTPUT}/boot/isolinux/netboot.cfg" ] ; then
    mkdir -p "${WORKING_DIR}/pxelinux.cfg/default"
    cp "${BUILD_OUTPUT}/boot/isolinux/netboot.cfg" "${WORKING_DIR}/pxelinux.cfg/default"
  else
    ewarn "File ${BUILD_OUTPUT}/boot/isolinux/netboot.cfg not found." ; eend 0
  fi

  mkdir -p "${WORKING_DIR}/pxelinux.cfg"

  if tar -C "$OUTPUTDIR" -jcf "${OUTPUT_FILE}" "grml_netboot_package_${GRML_NAME}_${VERSION}" ; then
    sha1sum "${OUTPUT_FILE}" > "${OUTPUT_FILE}.sha1"
    einfo "Generated netboot package ${OUTPUT_FILE}" ; eend 0
    rm -rf "${OUTPUTDIR}"
  else
    rm -rf "${OUTPUTDIR}"
    eerror "Could not generate netboot package ${OUTPUT_FILE}" ; eend 1
    bailout 21
  fi
}

create_netbootpackage
# }}}

# pack artifacts {{{
if [ -n "$PACK_ARTIFACTS" ]; then
  log "Packing artifcats"
  einfo "Packing artifacts"
  [ -f "${CHROOT_ARCHIVE}" ] && rm -r "${CHROOT_ARCHIVE}"
  tar -c -a -f ${CHROOT_ARCHIVE} --preserve-permissions -C "$(dirname ${CHROOT_OUTPUT})" "$(basename ${CHROOT_OUTPUT})"
  eend 0
fi
# }}}

# log build information to database if grml-live-db is installed and enabled {{{
dpkg_to_db() {
if [ -d /usr/share/grml-live-db ] ; then

  # safe defaults
  DPKG_LIST="/var/log/fai/$HOSTNAME/last/dpkg.list" # the dpkg --list output of the chroot:
  [ -n "$DPKG_DATABASE" ]  || DPKG_DATABASE=/var/log/grml-live.db
  [ -n "$DPKG_DBSCRIPT" ]  || DPKG_DBSCRIPT=/usr/share/grml-live-db/scripts/dpkg-to-db
  [ -n "$DPKG_DBOPTIONS" ] || DPKG_DBOPTIONS="--database $DPKG_DATABASE --logfile $LOGFILE --flavour $GRML_NAME --dpkg $DPKG_LIST"

  if ! [ -x "$DPKG_DBSCRIPT" ] ; then
    log "Error: $DPKG_DBSCRIPT is not executable, can not log dpkg information."
    eerror "Error: $DPKG_DBSCRIPT is not executable, can not log dpkg information." ; eend 1
    bailout 14
  fi

  # disable by default for now, not sure whether really everyone is using a local db file
  #if ! touch "$DPKG_DATABASE" ; then
  #  eerror "Error: can not write to ${DPKG_DATABASE}, can not log dpkg information." ; eend 1
  #  bailout 14
  #fi

  if ! [ -r "$DPKG_LIST" ] ; then
     log   "Warning: can not read $DPKG_LIST - can not provide information to $DPKG_DBSCRIPT (dirty build?)"
     ewarn "Warning: can not read $DPKG_LIST - can not provide information to $DPKG_DBSCRIPT (dirty build?)" ; eend 0
  else
     einfo "Logging $DPKG_LIST to database $DPKG_DATABASE"
     log "Logging $DPKG_LIST to database $DPKG_DATABASE"
     log "Executing $DPKG_DBSCRIPT $DPKG_DBOPTIONS"
     eindent

     if DB_INFO=$("$DPKG_DBSCRIPT" $DPKG_DBOPTIONS 2>&1) ; then
       einfo "$DB_INFO"
       eend 0
     else
       eerror "$DB_INFO"
       eend 1
     fi

     eoutdent
  fi

fi
}
# }}}

# finalize {{{
[ -n "$start_seconds" ] && SECONDS="$[$(cut -d . -f 1 /proc/uptime)-$start_seconds]" || SECONDS="unknown"
log "Successfully finished execution of $PN [$(date) - running ${SECONDS} seconds]"

dpkg_to_db # make sure we catch the last log line as well, therefore execute between log + einfo

einfo "Successfully finished execution of $PN [$(date) - running ${SECONDS} seconds]" ; eend 0
bailout 0
# }}}

## END OF FILE #################################################################
# vim:foldmethod=marker ts=2 ft=sh ai expandtab tw=80 sw=2
